<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coderifleman&#39;s blog</title>
  
  <subtitle>frontend development stories.</subtitle>
  <link href="http://blog.coderifleman.com/atom.xml" rel="self"/>
  
  <link href="http://blog.coderifleman.com/"/>
  <updated>2023-02-28T04:47:57.006Z</updated>
  <id>http://blog.coderifleman.com/</id>
  
  <author>
    <name>Coderifleman</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>실전! 리액트, 응집성 있게 가자!</title>
    <link href="http://blog.coderifleman.com/2023/02/27/hands_on_react_making_it_cohesive/"/>
    <id>http://blog.coderifleman.com/2023/02/27/hands_on_react_making_it_cohesive/</id>
    <published>2023-02-26T15:00:00.000Z</published>
    <updated>2023-02-28T04:47:57.006Z</updated>
    
    <content type="html"><![CDATA[    <figure title="undefined">      <a href="/images/hands_on_react_making_it_cohesive/react_cohesive.01.jpg" target="_blank">        <img           src="/images/hands_on_react_making_it_cohesive/react_cohesive.01.jpg"           alt=""           style=""        >      </a>          </figure>  <p>React, 아니 근래의 대부분 프레임워크는 컴포넌트를 지향한다. 문제를 작은 단위로 나누고 그것을 블랙박스 형태로 잘 포장, 조합하여 더 큰 문제를 해결하는 방법은 모든 공학 분야에서 공통적으로 애용하는 문제 해결 접근법이다.</p><p>하지만 소프트웨어 세계에서는 이런 접근법이 꽤 자주 지켜지지 않을 때가 있다. 가령 여러분이 은행 서비스의 주요 기능 중 하나인 송금 기능을 만들어야 한다고 해보자. 송금 기능에서 우리는 다양한 애플리케이션 비즈니스 로직을 도출할 수 있는데 여기에서는 간단히 송금액을 입력하는 과정만 생각해보자.</p><ol><li>송금액 입력 시 대상 계좌의 잔여금을 초과하지 않아야 한다.</li><li>송금액 입력 시 일회 이체 한도를 초과하지 않아야 한다.</li><li>송금액 입력 시 일일 이체 한도를 초과하지 않아야 한다.</li><li>초과 입력 시 송금이 가능한 최대 금액으로 자동 조정하고, 사용자에게 상황을 인지시켜야 한다.</li></ol><p>여러분은 유지보수성, 재사용성 등을 위해 송금액 입력 UI 요소와 관련 애플리케이션 비즈니스 로직을 하나의 컴포넌트 단위로 잘 포장하고 싶을 것이다.</p><pre class="language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">interface</span> <span class="token class-name">Props</span> <span class="token punctuation">&#123;</span>  account<span class="token operator">:</span> Account<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">RemittanceInput</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">&#123;</span> account <span class="token punctuation">&#125;</span><span class="token operator">:</span> Props</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>amount<span class="token punctuation">,</span> setAmount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>message<span class="token punctuation">,</span> setMessage<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> handleChange <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span>event<span class="token operator">:</span> ChangeEvent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">HTMLInputElement</span></span><span class="token punctuation">></span></span><span class="token plain-text">) => </span><span class="token punctuation">&#123;</span>    <span class="token comment">// 송금액 입력시 필요한 여러가지 검증 처리</span>  <span class="token punctuation">&#125;</span><span class="token plain-text">, []);  return (    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">></span></span><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">></span></span><span class="token plain-text">        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token plain-text">송금액 : </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token plain-text">        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span>          <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>remittance<span class="token punctuation">"</span></span>          <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>string<span class="token punctuation">"</span></span>          <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>amount <span class="token operator">||</span> <span class="token string">''</span><span class="token punctuation">&#125;</span></span>          <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>송금액을 입력해 주세요.<span class="token punctuation">"</span></span>          <span class="token attr-name">onChange</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>handleChange<span class="token punctuation">&#125;</span></span>        <span class="token punctuation">/></span></span><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>message<span class="token punctuation">&#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">></span></span><span class="token plain-text">  );&#125;</span></code></pre>  <p>UML 다이어그램으로 표현해보면 다음과 같다(문법은 함수지만 상태를 갖게 된 이상 객체와 다를 게 없기 때문에 UML 다이어그램으로 표현할 수 있다).</p>    <figure title="컴포넌트 내에 모두 위치 시켰을 경우의 UML 다이어그램">      <a href="/images/hands_on_react_making_it_cohesive/react_cohesive.02.png" target="_blank">        <img           src="/images/hands_on_react_making_it_cohesive/react_cohesive.02.png"           alt="컴포넌트 내에 모두 위치 시켰을 경우의 UML 다이어그램"           style=""        >      </a>          </figure>  <p>이 컴포넌트만으로 문제를 해결 할 수 있다면 다행이지만 실제 세계는 좀 더 복잡하다. 예를 들어 컴포넌트 내에서 관리하는 송금액(<code>amount</code>) 상태를 외부에 배치해야 하는 경우라면 어떨까? 사용자가 송금 버튼을 클릭하면 송금액을 알아야 하기 때문에 <code>RemittanceInput</code> 컴포넌트 내부에 감출 수 없다. 이 문제를 해결하는 방법은 실로 다양하지만 일단 다음과 같이 간단하게 풀어보자.</p><pre class="language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>account<span class="token punctuation">,</span> setAccount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useAccount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>amount<span class="token punctuation">,</span> setAmount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>message<span class="token punctuation">,</span> setMessage<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> handleChangeAccount <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 계좌 선택 시 필요한 여러가지 검증 처리</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> handleChangeRemittance <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 송금액 입력시 필요한 여러가지 검증 처리</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">></span></span><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">AccountSelecor</span></span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>account<span class="token punctuation">&#125;</span></span> <span class="token attr-name">onChange</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>handleChangeAccount<span class="token punctuation">&#125;</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">RemittanceInput</span></span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>amount<span class="token punctuation">&#125;</span></span> <span class="token attr-name">message</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>message<span class="token punctuation">&#125;</span></span>  <span class="token attr-name">onChange</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>handleChangeRemittance<span class="token punctuation">&#125;</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">RemitButton</span></span> <span class="token attr-name">account</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>account<span class="token punctuation">&#125;</span></span> <span class="token attr-name">amount</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>amount<span class="token punctuation">&#125;</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">></span></span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>  <p>송금액 상태와 관련된 애플리케이션 비즈니스 로직을 상위 컴포넌트로 모두 옮겼다. 이제 상태는 상위 컴포넌트에서 관리되므로 송금액 데이터가 필요한 다른 기능을 다루기 쉬워졌다. <code>RemittanceInput</code>은 수동적인 컴포넌트로 요소의 스타일만 결정할 뿐 송금액 입력과 관련한 어떠한 결정도 하지 않는다.</p><p>이러한 구현은 때에 따라서 충분할 수 있지만 유지보수성, 재사용성에 그다지 좋은 편은 아니다. 만약 다른 페이지에서도 <code>RemittanceInput</code>이 필요하다면 <code>App</code> 파일을 열어서 관련한 로직이 무엇인지 진중하게 살펴보며 살을 발라 복사해야 한다. 코드 중복은 두말 할 것 없고 중요한 로직을 누락하는 실수를 하기에도 좋다. 또, 추후 송금 정책이 변경된다면 송금액 입력 UI 요소가 있는 모든 페이지를 뒤져 빠짐없이 수정해야한다.</p><p>이번엔 송금액과 관련된 로직을 별도 훅스로 추출하고 <code>RemittanceInput</code> 가까이에 위치시켜보자. 그러면 테스트용이성도 높일 수 있으며 코드 중복이나 구현 누락도 피할 수 있다.</p><pre class="language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">interface</span> <span class="token class-name">Remittance</span> <span class="token punctuation">&#123;</span>  amount<span class="token operator">:</span> number<span class="token punctuation">;</span>  message<span class="token operator">:</span> string<span class="token punctuation">;</span>  <span class="token function-variable function">change</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">amount<span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">useRemittance</span><span class="token punctuation">(</span><span class="token parameter">account<span class="token operator">:</span> Account</span><span class="token punctuation">)</span><span class="token operator">:</span> Remittance <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>amount<span class="token punctuation">,</span> setAmount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>message<span class="token punctuation">,</span> setMessage<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> change <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">amount<span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 송금액 입력시 필요한 여러가지 검증 처리</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>account<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>     amount<span class="token punctuation">,</span>     message<span class="token punctuation">,</span>     change   <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><code>useRemittance</code>는 <code>Account</code>의 데이터를 기준으로 송금액 입력을 검증한다. 표현 로직이 없어 테스트하기 쉬우므로 테스트용이성을 높인다.</p><p><code>App</code>은 다음과 같이 수정할 수 있다.</p><pre class="language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>account<span class="token punctuation">,</span> setAccount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useAccount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> remittance <span class="token operator">=</span> <span class="token function">useRemittance</span><span class="token punctuation">(</span>account<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> handleChangeAccount <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 계좌 선택 시 필요한 여러가지 검증 처리</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">></span></span><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">AccountSelecor</span></span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>account<span class="token punctuation">&#125;</span></span> <span class="token attr-name">onChange</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>handleChangeAccount<span class="token punctuation">&#125;</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">RemittanceInput</span></span> <span class="token attr-name">remittacne</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>remittance<span class="token punctuation">&#125;</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">RemitButton</span></span> <span class="token attr-name">account</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>account<span class="token punctuation">&#125;</span></span> <span class="token attr-name">amount</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>remittance<span class="token punctuation">.</span>amount<span class="token punctuation">&#125;</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">></span></span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>다이어그램으로 표현하면 다음과 같다.</p>    <figure title="훅스를 분리한 경우의 다이어그램">      <a href="/images/hands_on_react_making_it_cohesive/react_cohesive.03.png" target="_blank">        <img           src="/images/hands_on_react_making_it_cohesive/react_cohesive.03.png"           alt="훅스를 분리한 경우의 다이어그램"           style=""        >      </a>          </figure>  <p>하나의 논리적인 패키지 단위를 만들고 그곳에 <code>RemittanceInput</code>, <code>useRemittance</code>를 함께 뒀다. <code>RemittanceInput</code>과 <code>useRemittance</code>는 <code>Remittance</code> 객체를 통해 소통한다. 서로 연관있는 것을 가까이 배치하여 관계에 대한 착오를 줄여 유지보수성을 높인다.</p><p>아직 아쉬운 부분이 있는데 논리적인 패키지 단위로 나눴으나 여전히 <code>RemittanceInput</code>과 <code>useRemittance</code>의 관계를 코드 상에서 알기 어렵다는 것이다. 그렇다고 <code>useRemittance</code>를 <code>RemittanceInput</code> 내부로 옮기면 송금액 데이터를 다른 컴포넌트가 참조할 수 없기 때문에 옳지 않다. 문제를 해결하기 위해 컨텍스트를 추가하여 <code>Remittance</code> 패키지를 좀 더 보강해보자.</p><pre class="language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">const</span> RemittanceContext <span class="token operator">=</span> createContext<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Remittance</span></span><span class="token punctuation">></span></span><span class="token plain-text">(</span><span class="token punctuation">&#123;</span>  amount<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>  message<span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>  <span class="token function-variable function">change</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">undefined</span><span class="token punctuation">&#125;</span><span class="token plain-text">);const RemittanceProvider = (  </span><span class="token punctuation">&#123;</span> children<span class="token punctuation">,</span> <span class="token operator">...</span>account <span class="token punctuation">&#125;</span><span class="token plain-text">: PropsWithChildren</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Account</span></span><span class="token punctuation">></span></span><span class="token plain-text">) => </span><span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> remittance <span class="token operator">=</span> <span class="token function">useRemittance</span><span class="token punctuation">(</span>account<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">RemittanceContext.Provider</span></span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>remittance<span class="token punctuation">&#125;</span></span><span class="token punctuation">></span></span><span class="token plain-text">      </span><span class="token punctuation">&#123;</span>children<span class="token punctuation">&#125;</span><span class="token plain-text">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">RemittanceContext.Provider</span></span><span class="token punctuation">></span></span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token plain-text">;</span></code></pre><p><code>Remittace</code> 객체를 컨텐스트 내에서 접근할 수 있도록 <code>RemittaceContext</code>와 <code>RemittanceProvider</code>를 추가했다. <code>RemittanceProvider</code>는 <code>useRemittance</code>의 반환값인 <code>Remittance</code> 객체를 <code>RemittaceContext.Provider</code>로 전달한다.</p><p>이제 <code>RemittacneContext</code>와 <code>RemittanceInput</code>을 연결하는 간단한 브릿지 컴포넌트를 작성해보자.</p><pre class="language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">const</span> <span class="token function-variable function">RemittanceInputWithContext</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> remittance <span class="token operator">=</span> <span class="token function">useContext</span><span class="token punctuation">(</span>RemittanceContext<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">RemittanceInput</span></span> <span class="token attr-name">remittance</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>remittance<span class="token punctuation">&#125;</span></span> <span class="token punctuation">/></span></span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><code>App</code>은 다음과 같다.</p><pre class="language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>account<span class="token punctuation">,</span> setAccount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useAccount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> handleChangeAccount <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 계좌 선택 시 필요한 여러가지 검증 처리</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">></span></span><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">AccountSelecor</span></span>          <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>account<span class="token punctuation">&#125;</span></span>          <span class="token attr-name">onChange</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>handleChangeAccount<span class="token punctuation">&#125;</span></span>        <span class="token punctuation">/></span></span><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">RemittacneProvider</span></span> <span class="token attr-name">account</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>account<span class="token punctuation">&#125;</span></span><span class="token punctuation">></span></span><span class="token plain-text">        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">RemittanceInputWithContext</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">RemittacneContext.Consumer</span></span><span class="token punctuation">></span></span><span class="token plain-text">          </span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">&#123;</span> amount <span class="token punctuation">&#125;</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">RemitButton</span></span> <span class="token attr-name">account</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>account<span class="token punctuation">&#125;</span></span> <span class="token attr-name">amount</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>amount<span class="token punctuation">&#125;</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">RemittacneContext.Consumer</span></span><span class="token punctuation">></span></span><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">RemittacneContext</span></span><span class="token punctuation">></span></span><span class="token plain-text">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">></span></span><span class="token plain-text">  );&#125;</span></code></pre><p><code>RemittanceInputWithContext</code>의 이름을 통해 특정 컨텍스트가 필요하다는 사실을 알 수 있다. <code>RemittanceProvider</code> 내부로 <code>useRemittance</code>를 감추고 <code>RemittanceInput</code>과의 관계를 맺어주므로 더이상 클라이언트가 신경쓸 필요 없다. 이제 적절한 위치에 <code>RemittacneContext</code>를 배치하여 송금액 상태를 보존하고 필요시 다른 컴포넌트에서도 활용할 수 있도록 한다. 이제 송금액 UI 요소를 관련 애플리케이션 비즈니스 로직과 함께 재활용 할 수 있고, 때로는 <code>RemiitanceInput</code>을 직접 사용할 수도 있어 확장성도 달성한다.</p><p>다이어그램으로 표현하면 다음과 같다.</p>    <figure title="컨텍스트를 활용한 경우의 다이어그램">      <a href="/images/hands_on_react_making_it_cohesive/react_cohesive.04.png" target="_blank">        <img           src="/images/hands_on_react_making_it_cohesive/react_cohesive.04.png"           alt="컨텍스트를 활용한 경우의 다이어그램"           style=""        >      </a>          </figure>  <p>중요한 건 관심사다. 기능 단위로 분리하는 게 아닌 관심사 단위로, 이곳 저곳에서 필요로 하는 로직이라는 점에 초점을 맞추지 말고 응집성 있게 관리하면 유지보수성, 재사용성을 높일 수 있다.</p>]]></content>
    
    
    <summary type="html">React.js에서 로직을 어떻게 응집성 있게 관리할 수 있는지 간단한 송금 예제와 함께 소개한다.</summary>
    
    
    
    <category term="JavaScript" scheme="http://blog.coderifleman.com/categories/JavaScript/"/>
    
    <category term="React" scheme="http://blog.coderifleman.com/categories/JavaScript/React/"/>
    
    
    <category term="JavaScript" scheme="http://blog.coderifleman.com/tags/JavaScript/"/>
    
    <category term="Architecture" scheme="http://blog.coderifleman.com/tags/Architecture/"/>
    
    <category term="React" scheme="http://blog.coderifleman.com/tags/React/"/>
    
    <category term="Design" scheme="http://blog.coderifleman.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>꾸준히 하기가 제일 어려워! JSer.info 번역 이야기</title>
    <link href="http://blog.coderifleman.com/2021/12/07/jserinfo_translation_story/"/>
    <id>http://blog.coderifleman.com/2021/12/07/jserinfo_translation_story/</id>
    <published>2021-12-06T15:00:00.000Z</published>
    <updated>2022-11-09T05:45:21.011Z</updated>
    
    <content type="html"><![CDATA[    <figure title="undefined">      <a href="/images/jserinfo_translation_story/jserinfo.01.jpg" target="_blank">        <img           src="/images/jserinfo_translation_story/jserinfo.01.jpg"           alt=""           style=""        >      </a>          </figure>  <p>위클리의 홍수에 살고 있다. 다양한 위클리를 구독하고 메일을 통해서 받아보지만, 그 많은 양을 매일 처리하긴 여간 힘든일이 아니다. 결국에는 쌓이고 쌓여 산적한 소식지로 인해 메일함을 여는 것조차 부담을 느끼게 된다. </p><p>그 과정에서 필자가 취한 전략이 있다. 바로 다양한 소식지를 구독해서 집중도를 떨어뜨리기보다는 “하나만이라도 매번 제대로 챙겨보자.”다.</p><p>필자는 영어에는 그다지 경험과 지식이 없다. 하지만 일본어는 나름 학창 시절 긴 오타쿠 생활을 통해 습득한 일종의 짝퉁 일본어를 갖고 있다. 어디 가서 자랑할 만한 언어 능력은 아니지만 간단한 일본어 기술 문서는 파파고를 벗 삼아 살펴볼 수는 있다.</p><p>그렇게 일본에 괜찮은 프런트엔드 관련 위클리 서비스가 없을까 찾아보다가 만나게 된 게 <a href="https://jser.info/">JSer.info</a> 다.</p>    <figure title="JSer.info 사이트 메인 페이지의 모습">      <a href="/images/jserinfo_translation_story/jserinfo.02.png" target="_blank">        <img           src="/images/jserinfo_translation_story/jserinfo.02.png"           alt="JSer.info 사이트 메인 페이지의 모습"           style=""        >      </a>      <figcaption>&lt;JSer.info 메인 페이지&gt;</figcaption>    </figure>  <p>JSer.info는 필자와 같은 고민 위에서 탄생한 위클리다. 다양한 위클리 소식을 한데 취합해서 주요한 정보만 간추려 두세 줄의 설명 구와 함께 매주 소식을 발행한다는 목표를 갖고 있다(<a href="https://jser.info/ko/about/">JSer.info 소개</a> 참고).</p><h2 id="책임감-주입"><a href="#책임감-주입" class="headerlink" title="책임감 주입!"></a>책임감 주입!</h2><p>꾸준히 살펴보기 위해서는 동기가 필요하다. 단순히 읽기만 한다면 금세 바쁘다는 핑계로 건너뛰거나 내팽개칠 게 뻔하다(나란 놈. 그런 놈). 좋은 방법이 없을까 고민한 끝에 결정한 방법이 “번역해서 공유하자” 다.</p><p>이는 순수하게 필자를 위한 전략이다. 번역은 글에 더 집중하게 한다. 눈으로만 훑고 간 것과는 다르게 더 오래 기억에 남고 필요한 정보를 찾아 활용하는 데 도움을 준다. 이어서 꾸준히 읽기 위해서 공유라는 활동을 통해 지속할 수 있는 에너지를 만든다 즉, 일종의 책임감 주입이다.</p><p>2014년 초 즈음 <a href="https://www.nts-corp.com/">NTS</a>(N-Tech Service)에 근무할 당시 JSer.info의 주인장 <a href="https://github.com/azu">azu</a>에게 메일을 보내 번역에 대한 허락을 받은 후 사내 메일을 통해 공유를 시작했다. 얼마 안 가 NTS의 기술 블로그 <a href="https://wit.nts-corp.com/">WIT</a>가 오픈했고 사내 메일이 아닌 WIT에 포스팅하는 방식으로 공유 방법을 전환했다.</p>    <figure title="WIT 블로그에 번역 & 공유한 JSer.info">      <a href="/images/jserinfo_translation_story/jserinfo.03.png" target="_blank">        <img           src="/images/jserinfo_translation_story/jserinfo.03.png"           alt="WIT 블로그에 번역 & 공유한 JSer.info"           style=""        >      </a>      <figcaption>&lt;WIT 블로그에 번역 & 공유한 JSer.info&gt;</figcaption>    </figure>  <p>WIT에 몇 주간 소식지를 공유하니 “왜 여기에 올리고 있지?”라는 생각이 문뜩 들었다. JSer.info는 깃허브를 통해 관리되고 있어 직접 PR 하는 편이 더 좋았기 때문이다. 얼마안가 JSer.info에 직접 기여하기 시작했다.</p><p>2014년 초부터 시작했으니 대략 7년이나 흘렀다. 꽤나 대견하다 싶지만 부끄럽게도 책임감 주입은 반은 성공했고 반은 실패했다.</p><h2 id="꾸준히-하기가-제일-어려워"><a href="#꾸준히-하기가-제일-어려워" class="headerlink" title="꾸준히 하기가 제일 어려워!"></a>꾸준히 하기가 제일 어려워!</h2><p>공유라는 방법으로 책임감을 주입하는 방법은 매년 활동을 이어가는 데는 성공했지만 매주 꾸준히 번역하는 데는 실패했다. 프로젝트 막바지나 정신없는 QA 또는 프로그래밍 문제에 오랜 시간 몰입할 때에는 건너뛰기 일쑤였다.</p>    <figure title="2015, 2016, 2017 JSer.info 번역 현황">      <a href="/images/jserinfo_translation_story/jserinfo.04.jpg" target="_blank">        <img           src="/images/jserinfo_translation_story/jserinfo.04.jpg"           alt="2015, 2016, 2017 JSer.info 번역 현황"           style=""        >      </a>      <figcaption>&lt;2015, 2016, 2017 JSer.info 번역 현황&gt;</figcaption>    </figure>  <p>빨간색은 번역하지 않고 건너뛴 것. 하얀색은 번역해서 커밋한 것이다. 2015년에는 55개 중 22개, 2016년에는 58개 중 31개, 2017년에는 54개 중 30개를 번역했다. 번역하지 않은 소식지는 필자 자신도 살펴보지 않았음을 의미한다.</p><p>누두고 찾지 않더라도 어딘가 공개된 공간에서 활동을 시작하면 책임감을 갖고 꾸준히 이어갈 수 있다고 생각했지만 정작 어떤 피드백이 없는 상황에서 그런 마음을 갖기란 만만치 않은 일이었다.</p><p>이대로는 안 되겠다는 생각에 2019년 새해에 JSer.info 소식지를 매주 꾸준히 번역해서 공유하자는 목표를 세우기도 했다. 그 결과 53개 중 40개를 번역하여 이전보다는 나아졌지만, 목표는 달성하지 못했다. </p><h2 id="2021년은-어땟을까"><a href="#2021년은-어땟을까" class="headerlink" title="2021년은 어땟을까?"></a>2021년은 어땟을까?</h2>    <figure title="2021 JSer.info 번역 현황">      <a href="/images/jserinfo_translation_story/jserinfo.05.png" target="_blank">        <img           src="/images/jserinfo_translation_story/jserinfo.05.png"           alt="2021 JSer.info 번역 현황"           style="max-width:340px"        >      </a>      <figcaption>&lt;2021 JSer.info 번역 현황&gt;</figcaption>    </figure>  <p>2021년에는 2019년의 실패를 모범 삼아 다시 한번 의지를 두텁게 갖기 위해 자신을 다독였다. 현재 11월 30일까지의 소식지가 발행됐는데 총 48개 중 43개를 번역하고 공유했다. 지나간 소식이라 큰 의미는 없지만, 미번역한 과거 5개의 소식지도 모두 번역하여 채울 생각이다.</p><p>물론 매주 정해진 시간에 규칙적으로 공유하진 못했기 때문에 활동이 완벽했다고 평가할 순 없다. 한 주 밀려서 두 주 소식을 한 번에 PR 하거나 몇 주 잊고 있다가 다시 챙기는 등 다소 불규칙적으로 활동했다. </p><p>그럼에도 JSer.info를 공유하기 시작한 2014년 이후 가장 많은 소식을 그나마 꾸준하게 나눠왔음은 분명하다. 더 훌륭한 내년을 위해 스스로 희망 섞인 칭찬을 해주고 싶다.  </p><h2 id="더-나은-내년을-위해"><a href="#더-나은-내년을-위해" class="headerlink" title="더 나은 내년을 위해"></a>더 나은 내년을 위해</h2><p>내년에는 더 꾸준하고 규칙적인 JSer.info 활동을 다짐해본다. 한주도 빠짐없이 매주 목요일에 소식을 나눌 수 있기를 희망한다(물론 힘들 거라고 장담한다. 하지만 목표는 세워보자). </p><p>이 글을 빌어 꾸준히 위클리를 취합하고 발행하고 계신 azu님의 노고에도 감사하다는 말을 전한다(앞으로도 잘 부탁 합니다). 아! 참고로 <a href="jserinfo.slack.com">JSer.info 슬랙 채널</a>이 있다. 일본 쪽 커뮤니티라 언어가 아쉽긴 하지만 관심 있는 분은 참고하길 바란다.</p><p>혹시 JSer.info를 가끔이라도 살펴보는 독자분. 혹은 소식을 기다리는 독자분이 있다면 응원의 메시지와 관심을 부탁한다.</p><p>코로나 시국 2021년 모두 고생 많았고 더 나은 2022년이 되길 희망하며 내년에도 잘 부탁한다고 인사 올려본다.</p><h2 id="덧붙임"><a href="#덧붙임" class="headerlink" title="덧붙임"></a>덧붙임</h2>    <figure title="네이버웹툰 W FE TECH팀의 Slack 기술 뉴스 채널">      <a href="/images/jserinfo_translation_story/jserinfo.06.jpg" target="_blank">        <img           src="/images/jserinfo_translation_story/jserinfo.06.jpg"           alt="네이버웹툰 W FE TECH팀의 Slack 기술 뉴스 채널"           style=""        >      </a>      <figcaption>&lt;네이버웹툰 W FE TECH팀의 Slack 기술 뉴스 채널&gt;</figcaption>    </figure>  <p>팀 내에서는 <a href="https://realtime.jser.info/">Realtime JSer.info</a>를 구독하여 실시간으로 소식을 공유하고 있으며 좋은 동료 덕분에 함께 토론하고 기술 이해도를 높이는데 도움을 받고 있다. 우리와 함께하고 싶은 분은 언제든지 환영! 네이버웹툰의 <a href="https://recruit.webtoonscorp.com/webtoon/ko/job/detail?annoId=20007007&classId=170&jobId=&classNm=developer&entTypeCd=&searchTxt=&jobKeyword=">W FE TECH</a> 팀도 관심있게 봐주길 바란다.</p><p>끝!</p>]]></content>
    
    
    <summary type="html">일본 프런트엔드 기술 위클리 JSer.info를 번역하고 공유해 온 이야기. 2021년 12월을 맞이하여 작성한 회고와 자기 반성글.</summary>
    
    
    
    <category term="Test" scheme="http://blog.coderifleman.com/categories/Test/"/>
    
    
    <category term="Weekly" scheme="http://blog.coderifleman.com/tags/Weekly/"/>
    
    <category term="FrontEnd" scheme="http://blog.coderifleman.com/tags/FrontEnd/"/>
    
    <category term="Translate" scheme="http://blog.coderifleman.com/tags/Translate/"/>
    
    <category term="JSer" scheme="http://blog.coderifleman.com/tags/JSer/"/>
    
    <category term="Jser.info" scheme="http://blog.coderifleman.com/tags/Jser-info/"/>
    
  </entry>
  
  <entry>
    <title>힘세고 오래가는 테스트 전략</title>
    <link href="http://blog.coderifleman.com/2021/11/17/a-strong-and-maintainable-test-strategy/"/>
    <id>http://blog.coderifleman.com/2021/11/17/a-strong-and-maintainable-test-strategy/</id>
    <published>2021-11-16T15:00:00.000Z</published>
    <updated>2022-11-09T05:45:21.010Z</updated>
    
    <content type="html"><![CDATA[    <figure title="undefined">      <a href="/images/a-strong-and-maintainable-test-strategy/test.01.png" target="_blank">        <img           src="/images/a-strong-and-maintainable-test-strategy/test.01.png"           alt=""           style=""        >      </a>          </figure>  <p>소위 프런트엔드 그러니까 웹 애플리케이션은 왜 테스트하기 힘들까? 복잡하게 생각 할 필요 없다. 허구헌날 바뀌기 때문이다.</p><p>사용자 프로필을 출력하는 모달 컴포넌트를 떠올려보자. 여러분은 꽤나 신경써서 유닛 테스트도 작성했다. 신성한 초록색 바도 확인했다. 자 이제 PR을 보내볼까? 하는 순간 UI는 바뀐다(그… 그 정도는 아니야). 애써 작성한 유닛테스트의 3분의 1이 실패하고 테스트를 하나하나 고쳐야한다. 내일도 모레도 UI는 바뀌고 테스트는 다시 깨지며 또 고쳐야 한다.</p><p>시간이 지날수록 테스트 관리 비용은 크지만 얻을 수 있는 긍정적인 효과는 적다고 느껴진다. 점점 테스트와 거리가 생기기 시작하고 결국엔 이별을 맞이한다.</p>    <figure title="가! 가란말이야!">      <a href="/images/a-strong-and-maintainable-test-strategy/test.02.png" target="_blank">        <img           src="/images/a-strong-and-maintainable-test-strategy/test.02.png"           alt="가! 가란말이야!"           style=""        >      </a>      <figcaption>&lt;가! 가란말이야!!&gt;</figcaption>    </figure>  <p>UI는 자주 바뀐다. 왜냐하면 가장 바꾸기 쉽기 때문이다(심지어 효과적이다). 그래서 UI를 테스트하지 않겠다는 의견도 어느정도 이해가 된다. 하지만 UI에 대한 테스트 포기가 곧 모든 코드에 대한 테스트 포기로 이어져서는 안된다.</p><p>힘세고 오래가는 테스트 전략은 간단하다.</p><p>우선 테스트하기 편안해야 한다. 즉, 거치적거리는 것 없이 유닛 테스트를 작성할 수 있어야 한다. 밥과 함께 씹히는 돌을 한번은 참고 넘길 수 있어도 만약 계속 반복된다면 여러분은 숟가락을 집어던질 것이다.</p>    <figure title="에잇! 더는 못먹겠네!">      <a href="/images/a-strong-and-maintainable-test-strategy/test.03.png" target="_blank">        <img           src="/images/a-strong-and-maintainable-test-strategy/test.03.png"           alt="에잇! 더는 못먹겠네!"           style=""        >      </a>      <figcaption>&lt;에잇! 더는 못먹겠네!&gt;</figcaption>    </figure>  <p>두번째로 상대적으로 덜 변하는 것을 테스트한다. 덜 변하는 것은 그렇지 않은 것에 비해 더 중요한 내용을 담고 있기 마련이다. 다시 말해서 애플리케이션 규칙이나 서비스 정책을 식별하고, 표현이라는 맥락에서 분리할 수 있어야 한다.</p><p>정리하자면 다음과 같다.</p><ol><li>UI 컴포넌트는 개인의 판단에 따라 테스트 작성 여부를 결정할 수 있도록 한다.</li><li>중요한 것(상대적으로 덜 변하는 것)을 식별하여 테스트 작성하기 쉬운 방법으로 구현하고 테스트한다.</li></ol><p>어떻게 끝내야 할 지 모르겠지만 일단 하고 싶은 말은 여기까지다. </p><p>끝.</p>]]></content>
    
    
    <summary type="html">웹 애플리케이션에서 무엇을 테스트 해야 할지 또, 어떤 관점에서 코드를 바라봐야 장기적으로도 유용한 결과물을 만들 수 있는지 이야기합니다.</summary>
    
    
    
    <category term="Test" scheme="http://blog.coderifleman.com/categories/Test/"/>
    
    
    <category term="Development" scheme="http://blog.coderifleman.com/tags/Development/"/>
    
    <category term="Test" scheme="http://blog.coderifleman.com/tags/Test/"/>
    
    <category term="UnitTest" scheme="http://blog.coderifleman.com/tags/UnitTest/"/>
    
  </entry>
  
  <entry>
    <title>리액트 훅스(react hooks)와 험블 객체 패턴(humble object pattern) 그리고 테스트</title>
    <link href="http://blog.coderifleman.com/2021/04/21/react-hooks-and-humble-object-pattern-and-tests/"/>
    <id>http://blog.coderifleman.com/2021/04/21/react-hooks-and-humble-object-pattern-and-tests/</id>
    <published>2021-04-20T15:00:00.000Z</published>
    <updated>2022-11-09T05:45:21.013Z</updated>
    
    <content type="html"><![CDATA[    <figure title="undefined">      <a href="/images/react-hooks-and-humble-object-pattern-and-tests/hooks.00.jpg" target="_blank">        <img           src="/images/react-hooks-and-humble-object-pattern-and-tests/hooks.00.jpg"           alt=""           style=""        >      </a>          </figure>  <p>UI를 개발하는 프런트엔드 개발자라면 누구나 빠질 수 있는 함정이 있다. UI 개발 특성상 무엇보다 뷰가 중요해 보이기 때문에 너무나 쉽게 뷰부터 시작한다는 것. </p><p>컴포넌트를 작성하다가 필요한 데이터가 있으면 선언하고, 이어서 작성하다가 장황한 로직이 생기면 커스텀 훅스로 분리하는 등 일정한 규칙 없이 산발적으로 이뤄진다. 자연스럽게 중요한 모델 정보와 그 모델을 조작하는 로직도 산발적으로 흩뿌려지는데 결과적으로 테스트하기 매우 불편한 코드가 작성되고 결국엔 테스트를 포기하게 한다.</p><p>중 / 대규모 프로젝트에 참여해 본 사람은 알 것이다. 낮은 응집성이나 관심사 파편화도 큰 문제지만 무엇보다 테스트 코드 없는 영역을 수정해야 할 때만큼 불안감을 가져다주는 경우는 없다. UI 개발에서 테스트가 어렵다는 건 충분히 공감한다. 하지만 중요한 비즈니스 로직은 가능한한 테스트를 작성해야만 한다.</p><h2 id="험블-객체-패턴"><a href="#험블-객체-패턴" class="headerlink" title="험블 객체 패턴"></a>험블 객체 패턴</h2><blockquote><p>험블 객체 패턴은 디자인 패턴으로, 테스트하기 어려운 행위와 테스트하기 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게하는 방법으로 … 중략 … 가장 기본적인 본질은 남기고, 테스트하기 어려운 행위를 모두 험블 객체로 옮긴다. 나머지 모듈에는 험블 객체에 속하지 않은, 테스트하기 쉬운 행위를 모두 옮긴다.</p><p>Clean Architecture, 로버트 C. 마틴 저 / 송준이 역 | 인사이트(insight) 출판</p></blockquote><p>뷰 그러니까 리액트 컴포넌트는 험블 객체다. 테스트하기 어렵고 불편하다. 이곳에 중요한 로직을 두면 자연스럽게 그 로직도 테스트하기 어려워진다. 중요한 로직은 컴포넌트에서 분리하고 테스트하기 쉬운 곳에 두어야 한다. 그럼 테스트하기 쉬운 공간이 어딜까?</p><h2 id="건강한-개발-루틴"><a href="#건강한-개발-루틴" class="headerlink" title="건강한 개발 루틴"></a>건강한 개발 루틴</h2><p>그 공간을 이야기 하기에 앞서 건강한 개발 루틴을 이야기해보자. 필자가 말하는 건강한 개발 루틴이란 개발의 순서가 일정하며 그 과정에 생산된 코드가 충분히 검증될 수 있는 순서와 방법을 말한다. </p><ol><li>요구사항을 분석하고 모델을 정리한다.</li><li>모델을 토대로 데이터를 실체화하고 비즈니스 로직을 작성한다.</li><li>비즈니스 로직을 검증하는 테스트 코드를 작성한다.</li><li>뷰를 작성하고 사용자 이벤트와 비즈니스 로직을 잇는다.</li><li>(중요도에 따라) 컴포넌트를 검증하는 테스트 코드를 작성한다.</li></ol><p>컴포넌트에서 시작하지 말자. 만들어야 할 것이 무엇인지 알아야만 좋은 코드를 작성 할 수 있다. 키보드에서 손을 내려놓고 조금은 멀리서 관찰할 시간이 필요하다. 어떤 문제를 해결해야 하는지 이해하고 다양한 정책을 찾고 정리해야 한다.</p><p>그러고 나면 모델을 찾을 수 있다. 그리고 이 모델을 토대로 데이터를 실체화하고 표현에 활용한다. 이제 구현할 데이터와 비즈니스 로직을 어디에 두어야 할지 고민할 순서다. 중요한 로직은 테스트하기 쉬운 곳에 둬야 한다. 그래야만 지속해서 테스트를 작성하고 커버리지도 높일 수 있다.</p><p>테스트하기 쉬운 공간? 그래 훅스다. 훅스를 활용하면 중요한 데이터와 정책을 효율적으로 캡슐화하고 관리할 수 있다. 훅스를 단순히 뷰만을 위한 함수 공간 정도로 바라보는 관점에서 벗어나면 더 다양한 아키텍처를 찾아낼 수 있다.</p><h2 id="사례-소개"><a href="#사례-소개" class="headerlink" title="사례 소개"></a>사례 소개</h2><h3 id="useBasicFormData"><a href="#useBasicFormData" class="headerlink" title="useBasicFormData"></a>useBasicFormData</h3><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">useBasicFormData</span><span class="token punctuation">(</span>initialData<span class="token operator">:</span> UserBasicData<span class="token punctuation">)</span><span class="token operator">:</span> State <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span>initialData<span class="token punctuation">)</span>  <span class="token keyword">const</span> <span class="token function-variable function">changeName</span> <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token comment">/* ... */</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token function-variable function">changeEmail</span> <span class="token operator">=</span> <span class="token punctuation">(</span>email<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token comment">/* ... */</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token function-variable function">changeWorkStatus</span> <span class="token operator">=</span> <span class="token punctuation">(</span>workStatus<span class="token operator">:</span> WorkStatus<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> newState <span class="token operator">=</span> <span class="token function">produce</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> draft <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>workStatus <span class="token operator">===</span> WorkStatus<span class="token punctuation">.</span>InEmploy<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        draft<span class="token punctuation">.</span>offboardingDate <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      draft<span class="token punctuation">.</span>workStatus <span class="token operator">=</span> workStatus<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setState</span><span class="token punctuation">(</span>newState<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">/* ... 생략 ... */</span><span class="token punctuation">&#125;</span></code></pre><p><code>useBasicFormData</code>는 사용자 기본 정보를 관리하는 훅스다. 해당 훅스 내에는 사용자의 기본 정보 즉, 이름이나 이메일, 근무 상태 등을 변경할 수 있는 함수가 존재한다. </p><p>여기에서 <code>changeWorkStatus</code> 함수 내 위치한 분기 문에 집중해보자. 해당 분기 문은 “근무 상태를 재직자로 설정하면 퇴직일을 초기화해야 한다”라는 서비스 정책을 나타내는 중요한 로직이다. 이 정책은 테스트 될 필요가 있으며 또 드러나야 한다.</p><p>이 로직이 특정 컴포넌트 공간에 존재한다고 생각해보자. 해당 컴포넌트에는 다른 다양한 로직이 뒤섞여 있다. 테스트는 둘째치고 중요한 로직이 여러 곳에 흩뿌려지거나 드러나지 않아 지나치기 쉽다.</p><h3 id="테스트-케이스"><a href="#테스트-케이스" class="headerlink" title="테스트 케이스"></a>테스트 케이스</h3><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token function">it</span><span class="token punctuation">(</span><span class="token string">'재직자로 설정하면 퇴직일이 undefined로 설정 돼야 한다.'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> result <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">renderHook</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">useBasicFormData</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    workStatus<span class="token operator">:</span> WorkStatus<span class="token punctuation">.</span>OffBoard<span class="token punctuation">,</span>    offboardingDate<span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">act</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    result<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">changeWorkStatus</span><span class="token punctuation">(</span>WorkStatus<span class="token punctuation">.</span>InEmploy<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">expect</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>current<span class="token punctuation">.</span>workStatus<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toEqual</span><span class="token punctuation">(</span><span class="token string">'IN_EMPLOY'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">expect</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>current<span class="token punctuation">.</span>offboardingDate<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBeUndefined</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>훅스 테스트에 <code>@testing-library/react-hooks</code>의 <code>renderHook</code>과 <code>act</code>를 사용하고 있다. 해당 라이브러리가 훅스를 한층 더 테스트하기 쉽도록 한다.</p><p><code>useBaiscFormData</code>로 데이터를 생성하고 <code>act</code>를 이용해 근무상태를 변경한다. 변경 후 <code>offboardingDate</code>가 <code>undefined</code>으로 변경됐는지 확인하여 정책을 검증한다.</p><p>훅스 테스트는 컴포넌트보다 상대적으로 쉽고 단순하다. 이곳에 데이터와 비즈니스 로직을 두는 것으로 험블 객체 패턴을 실현하고 패턴의 장점을 취할 수 있다. </p><h2 id="끝으로"><a href="#끝으로" class="headerlink" title="끝으로"></a>끝으로</h2><p>리액트 v16.8에 훅스가 추가되고 벌써 2년이 지났다. 커뮤니티는 Redux 기반 리액트 애플리케이션에서 훅스와 컨텍스트를 활용하는 방식으로 전환하고 있다. 필자는 Redux 기반 애플리케이션에서 데이터와 비즈니스 로직을 액션에 작성하고 테스트했다. 액션 생성자라는 단순한 함수 정의에서 벗어나면 뷰 외의 다양한 로직을 테스트하기에 좋은 공간이 된다.</p><p>하지만 훅스와 컨텍스트 기반으로 넘어오면서 건강한 개발 루틴을 잠시 잃었다. 필자는 훅스를 단순하게 해석했고 때문에 비즈니스 로직을 둘 적당한 장소가 없어 자연스럽게 컴포넌트부터 시작했는데 이때부터 혼란이 찾아왔다.</p><p>현재는 애플리케이션 규모에 따라 훅스를 여러 가지 용도로 정의하고 활용한다. 훅스를 뷰만을 위한 단순한 기능이 아니라 뷰보다 저수준인 다른 계층으로써 활용하면 개발 간 만나는 많은 문제를 해결할 수 있다.</p><p>이해를 돕기 위해 할 일 관리 애플리케이션을 작성했다. 관심 있는 분은 참고하길 바란다. 해당 예제는 요구사항 규모에 맞춰 작성했으므로 구현 형태, 디렉터리 구조 등이 다른 애플리케이션에는 잘 어울리지 않을 수 있다는 점을 인지해주길 바란다.</p><ul><li><a href="https://github.com/uyeong/todomvc-with-hooks">uyeong/todomvc-with-hooks</a></li></ul><p>예제를 보면 <code>hooks</code> 디렉터리와 <code>sources</code> 디렉터리에 모두 훅스가 존재한다. 단순한 유틸리티 성 훅스를 하나의 디렉터리에 두게 되면 중요한 훅스가 파일 구조 내에서 드러나지 않기 때문에 <code>sources</code> 라는 별도의 디렉터리로 분리했다.</p><p>필자가 작성한 <a href="https://github.com/uyeong/todomvc-with-hooks/blob/main/src/sources/useTodos.ts">useTodos</a>와 클래스로 구현한 <a href="https://github.com/tastejs/todomvc/blob/gh-pages/examples/typescript-react/js/todoModel.ts">todoModel</a>를 함께 비교해보면 뭔가 아하! 하는 게 있지 않을까 기대한다.</p>]]></content>
    
    
    <summary type="html">훅스 관점에서 어떻게 테스트 용이성과 유지보수성 높은 애플리케이션을 일관된 루틴으로 개발하고 설계할 수 있는지 소개한다.</summary>
    
    
    
    <category term="JavaScript" scheme="http://blog.coderifleman.com/categories/JavaScript/"/>
    
    <category term="React" scheme="http://blog.coderifleman.com/categories/JavaScript/React/"/>
    
    
    <category term="Development" scheme="http://blog.coderifleman.com/tags/Development/"/>
    
    <category term="Test" scheme="http://blog.coderifleman.com/tags/Test/"/>
    
    <category term="UnitTest" scheme="http://blog.coderifleman.com/tags/UnitTest/"/>
    
    <category term="JavaScript" scheme="http://blog.coderifleman.com/tags/JavaScript/"/>
    
    <category term="React" scheme="http://blog.coderifleman.com/tags/React/"/>
    
    <category term="Hooks" scheme="http://blog.coderifleman.com/tags/Hooks/"/>
    
    <category term="ReactHooks" scheme="http://blog.coderifleman.com/tags/ReactHooks/"/>
    
    <category term="Design" scheme="http://blog.coderifleman.com/tags/Design/"/>
    
    <category term="HumbleObjectPattern" scheme="http://blog.coderifleman.com/tags/HumbleObjectPattern/"/>
    
    <category term="DesignPattern" scheme="http://blog.coderifleman.com/tags/DesignPattern/"/>
    
  </entry>
  
  <entry>
    <title>Node.js에서의 프로토타입 오염 공격이란 무엇인가</title>
    <link href="http://blog.coderifleman.com/2019/07/19/prototype-pollution-attacks-in-nodejs/"/>
    <id>http://blog.coderifleman.com/2019/07/19/prototype-pollution-attacks-in-nodejs/</id>
    <published>2019-07-18T15:00:00.000Z</published>
    <updated>2022-11-09T05:45:21.013Z</updated>
    
    <content type="html"><![CDATA[    <div class="alert alert--info">              <strong class="alert__title">          읽기전에...        </strong>            <div class="alert__body">        <p>이 문서는 「<a href="https://jovi0608.hatenablog.com/entry/2018/10/19/083725">Node.jsにおけるプロトタイプ汚染攻撃とは何か</a>」를 번역한 글입니다. 원작자에게 번역 및 배포 허락을 받았습니다. 프로토타입 오염 취약성이 많은 분에게 알려지길 바랍니다.</p>      </div>    </div>  <h2 id="시작하면서"><a href="#시작하면서" class="headerlink" title="시작하면서"></a>시작하면서</h2><p>최근 까닭이 있어 노드의 보안 사항을 조사하고 있는데요. 올해 5월에 개최된 <a href="https://nsec.io/">North Sec 2018</a>, 보안 연구자 <a href="https://github.com/HoLyVieR">Olivier Arteau</a>의 “<a href="https://www.youtube.com/watch?v=LUsiFV3dsK8">Prototype pollution attacks in NodeJS applications</a>“라는 재미있는 발표를 발견했습니다.</p><p>이 발표의 논문, 발표 자료, 데모 영상을 깃허브에 공개했으며 때마침 발표 영상도 유튜브를 통해 공개됐습니다.</p><ul><li><a href="https://github.com/HoLyVieR/prototype-pollution-nsec18">HoLyVieR/prototype-pollution-nsec18</a></li><li><a href="https://www.youtube.com/watch?v=LUsiFV3dsK8">Prototype pollution attacks in NodeJS applications</a></li></ul><p>이 발표에서는 공격자가 자바스크립트 언어 고유의 프로토타입 체인 동작 원리를 이용해 웹 서버를 공격하는 방법을 이야기합니다.</p><p>발표자는 npm에서 받을 수 있는 모듈을 조사해 lodash를 시작으로 많은 모듈에 프로토타입 오염 취약점이 있는 것을 발견하고 보고했습니다. 그리고 실제 취약점이 있는 Ghost CMS를 이용, 비밀번호 재설정 요청에 필요한 데이터를 변조해 서버상에서 계산기 애플리케이션을 실행시키는 데모까지 성공합니다.</p><p>자바스크립트 실행 환경에 있어 프로토타입 오염 발생 위험성은 오래전부터 이야기 돼 왔지만 이것이 Node.js 환경의 웹 서버를 공격하는데 활용될 것이라고는 생각지 못했을 것 같습니다.</p><p>이 문서에서는 개인적으로도 기억해둘 겸 해당 공격의 원리에 관해서 설명하고자 합니다.</p><h2 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h2><p>객체의 프로토타입을 참조하는 <code>__proto__</code>는 예로부터 보편적으로 사용해온 기능입니다. 정식 사양은 아니었지만, 실정과 구현 현황을 소급 인정하고 브라우저 간 호환을 위해 ECMAScript2015 사양에 추가됐습니다.</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto">Object.prototype.__proto__ - MDN web docs</a></li></ul><p>이 외에도 <code>__proto__</code>에 대한 게터 / 셋터와 같은 기능인 <code>Object.setPrototypeOf</code> / <code>getPrototypeOf</code>도 규정돼 있습니다. 현재 Node.js 환경에서도 모두 사용할 수 있습니다. 하지만 MDN에서는 프로토타입을 변경하는 것을 비권장합니다. </p><h2 id="프로토타입-오염"><a href="#프로토타입-오염" class="headerlink" title="프로토타입 오염"></a>프로토타입 오염</h2><p>프로토타입 오염은 무엇일까. 방법에는 여러 가지 있겠지만 가장 기본은 객체 리터럴의 <code>__proto__</code>는 <code>Object.prototype</code>과 같다는 것을 이용해 다른 객체 속성에 영향을 주는 방식입니다.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>obj1<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>polluted <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">.</span>polluted<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span></code></pre><p>위 예제에서 obj1의 프로토타입 객체를 조작했습니다. 이제 아무 관계 없는 <code>obj2</code> 속성의 값(obj2.polluted)이 <code>undefined</code>가 아니라 <code>1</code>로 출력됩니다.</p><p>발표에서는 아래와 같은 객체 프로토타입 오염이 일어날 수 있는 세 가지 패턴을 소개합니다. 모두 <code>__proto__</code>을 포함한 문자열을 key로 이용해 정확하지 않은 데이터를 객체에 등록 시켜 <code>Object.prototype</code> 오염을 노리는 방식입니다.</p><h3 id="속성-설정"><a href="#속성-설정" class="headerlink" title="속성 설정"></a>속성 설정</h3><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">isObject</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> obj <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> obj <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">function</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> keylist <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> e <span class="token operator">=</span> keylist<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>keylist<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> obj<span class="token punctuation">[</span>e<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">setValue</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">,</span> keylist<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token keyword">return</span> obj<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">setValue</span><span class="token punctuation">(</span>obj1<span class="token punctuation">,</span> <span class="token string">"__proto__.polluted"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">.</span>polluted<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span></code></pre><h3 id="객체-병합"><a href="#객체-병합" class="headerlink" title="객체 병합"></a>객체 병합</h3><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isObject</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isObject</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">merge</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      a<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">'&#123;"__proto__":&#123;"polluted":1&#125;&#125;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">merge</span><span class="token punctuation">(</span>obj1<span class="token punctuation">,</span> obj2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> obj3 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj3<span class="token punctuation">.</span>polluted<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span></code></pre><h3 id="객체-복사"><a href="#객체-복사" class="headerlink" title="객체 복사"></a>객체 복사</h3><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">'&#123;"__proto__":&#123;"polluted":1&#125;&#125;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token function">clone</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> obj3 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj3<span class="token punctuation">.</span>polluted<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span></code></pre><p>위와 비슷한 기능을 제공하는 유저 모듈에서 프로토타입 오염 취약점이 발견, 수정되고 있습니다. 수정된 부분을 살펴보았는데 key에 <code>__proto__</code>가 있을 경우 건너뛰도록 돼 있습니다.</p><p>공격자는 외부에서 <code>Object.prototype</code>을 조작할 수 있기 때문에 for-in 문의 오작동을 노려 악의적으로 속성을 수정하거나 <code>toString</code>, <code>valueOf</code> 등의 메서드를 재정의할 수도 있습니다. DoS는 간단하게 일으킬 수 있겠네요.</p><h2 id="실제-공격"><a href="#실제-공격" class="headerlink" title="실제 공격"></a>실제 공격</h2><p>발표에서는 실제 CMS 서버에 비밀번호 재설정에 필요한 JSON을 조작해 공격하는 방법을 소개합니다.</p><p>아이러니하게 객체 프로토타입 오염 공격이 성공한 경우에 서버 크래시 없이 동작하도록 하는 것은 꽤 어려운 기술입니다. 데모에서는 여러가지 방안을 고안해 CMS 템플릿을 조작하고, 테스트용으로 남겨져 있는 템플릿을 조작하여 임의의 자바스크립트를 서버상에서 실행(계산기 앱을 시작) 시키는 과정을 보여줍니다.</p><p>이 글에서는 JSON을 받아 어떠한 처리를 하는 간단한 웹 API 서버를 이용해 프로토타입 오염 공격에 의해 응답이 조작되는 샘플을 소개합니다.</p><p>다음은 서버 코드입니다. 외부에서 전달받은 JSON을 그대로 복사하고 있습니다.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">isObject</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> obj <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> obj <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">function</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 이 부분에서 key가 __proto__ 일 때에 건너뛰어야 한다.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isObject</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isObject</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">merge</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      a<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">function</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">const</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>express<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 여기에서 악의적인 JSON을 그대로 복사함으로써 객체의 프로토타입 오염이 일어난다</span>  <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token function">clone</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> r <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// 프로토타입 오염에 의해 r.status가 변조된다.</span>  <span class="token keyword">const</span> status <span class="token operator">=</span> r<span class="token punctuation">.</span>status <span class="token operator">?</span> r<span class="token punctuation">.</span>status<span class="token operator">:</span> <span class="token string">'NG'</span><span class="token punctuation">;</span>  res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">1234</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>클라이언트는 <code>__proto__</code> 속성을 갖는 JSON을 서버에 전달해 공격합니다.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> client <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  host<span class="token operator">:</span> <span class="token string">'localhost'</span><span class="token punctuation">,</span>  port<span class="token operator">:</span> <span class="token number">1234</span><span class="token punctuation">,</span>  method<span class="token operator">:</span> <span class="token string">'POST'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  res<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">chunk</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>chunk<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token string">'&#123;"__proto__":&#123;"status":"polluted"&#125;&#125;'</span><span class="token punctuation">;</span>client<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'content-type'</span><span class="token punctuation">,</span> <span class="token string">'application/json'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>client<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>공격 결과. 전달한 JSON에 의해 서버의 객체 프로토타입이 오염돼 응답의 값이 <code>NG</code>가 아니라 <code>polluted</code>로 변경돼 내려옵니다.</p><pre class="language-js" data-language="js"><code class="language-js">$ node client<span class="token punctuation">.</span>jspolluted</code></pre><h2 id="대책"><a href="#대책" class="headerlink" title="대책"></a>대책</h2><p>이 공격을 방지하는 대책으로 다음 세 가지 방법이 있습니다.</p><ul><li><strong>Object.freeze</strong> : <code>Object.prototype</code>이나 <code>Object</code>를 <code>freeze</code>하여 변경을 불가능하게 하는 방법입니다. 부작용으로 정상적인 모듈임에도 이 조치로 동작하지 않을 수도 있습니다. </li><li><strong>JSON schema</strong> : <a href="https://ajv.js.org/">avj</a> 모듈 등을 사용해 JSON을 검증합니다.</li><li><strong>Map</strong> : key / value를 저장하는데 객체를 사용하지 않고 <code>Map</code>을 사용합니다. 단, ES5 이전 환경에서는 사용할 수 없습니다.</li></ul><p>의식하지 않으면 언제든지 이 취약점이 노출될 수 있습니다.</p><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><p>이 글을 정리하면서도 다른 객체를 단순히 깊은 복사 하는 것만으로 취약점이 노출된다는 사실에 놀랐습니다. 역시 외부에서 전달받은 데이터를 처리할 때엔 신중해야 합니다. </p><p>취약점이 알려진 사용자 모듈 대부분은 이미 고쳐진 상태입니다. 그럼에도 신경 쓰인다면 한번 <code>npm audit</code>으로 확인해보시기 바랍니다.</p><pre class="language-text" data-language="text"><code class="language-text">$ npm audit                        &#x3D;&#x3D;&#x3D; npm audit security report &#x3D;&#x3D;&#x3D; # Run  npm install lodash@4.17.11  to resolve 1 vulnerability   Low             Prototype Pollution   Package         lodash   Dependency of   lodash   Path            lodash   More info       https:&#x2F;&#x2F;nodesecurity.io&#x2F;advisories&#x2F;577   found 1 low severity vulnerability in 1 scanned package  run &#96;npm audit fix&#96; to fix 1 of them.</code></pre>]]></content>
    
    
    <summary type="html">__proto__을 이용한 프로토타입 오염(prototype pollution) 공격의 원리를 설명하면서 노드 환경에서 실제 공격이 가능한 사례를 함께 소개합니다.</summary>
    
    
    
    <category term="JavaScript" scheme="http://blog.coderifleman.com/categories/JavaScript/"/>
    
    <category term="Security" scheme="http://blog.coderifleman.com/categories/JavaScript/Security/"/>
    
    
    <category term="Development" scheme="http://blog.coderifleman.com/tags/Development/"/>
    
    <category term="JavaScript" scheme="http://blog.coderifleman.com/tags/JavaScript/"/>
    
    <category term="Node" scheme="http://blog.coderifleman.com/tags/Node/"/>
    
    <category term="Security" scheme="http://blog.coderifleman.com/tags/Security/"/>
    
    <category term="ECMAScript" scheme="http://blog.coderifleman.com/tags/ECMAScript/"/>
    
  </entry>
  
  <entry>
    <title>실행 취소 / 다시 실행 기능 구현하기(feat. serializr)</title>
    <link href="http://blog.coderifleman.com/2019/06/29/create-the-undo-redo-feature/"/>
    <id>http://blog.coderifleman.com/2019/06/29/create-the-undo-redo-feature/</id>
    <published>2019-06-28T15:00:00.000Z</published>
    <updated>2022-11-09T05:45:21.010Z</updated>
    
    <content type="html"><![CDATA[    <figure title="undefined">      <a href="/images/create-the-undo-redo-feature/undo-redo.00.jpg" target="_blank">        <img           src="/images/create-the-undo-redo-feature/undo-redo.00.jpg"           alt=""           style=""        >      </a>          </figure>  <p>이 문서는 자바스크립트 라이브러리 <a href="https://github.com/mobxjs/serializr">serializr</a>를 사용하여 실행 취소 / 다시 실행 구현 방법을 소개한다. 이와 같은 기능을 구현하는 데 있어 적게나마 도움이 되길 바란다.</p><h2 id="예제-소개"><a href="#예제-소개" class="headerlink" title="예제 소개"></a>예제 소개</h2>    <p data-height="300" data-theme-id="0" data-slug-hash="RzZBdX" data-default-tab="result" data-user="uyeong" data-embed-version="2" data-pen-title="RzZBdX" class="codepen">      See the Pen <a href="http://codepen.io/uyeong/pen/RzZBdX/">RzZBdX</a> by Uyeong Ju (<a href="http://codepen.io/uyeong">@uyeong</a>) on <a href="http://codepen.io">CodePen</a>.    </p>  <p>이해를 돕기 위해 원, 사각형, 삼각형 중 하나를 생성하고, 끌어다 놓거나 삭제할 수 있는 간단한 애플리케이션을 준비했다. 여기에 실행 취소 / 다시 실행 기능을 추가하고자 한다. 하지만 그 전에 애플리케이션의 구조를 모델, 표현(presentation), 이벤트 핸들러로 나눠 간단히 살펴보고 넘어가자.</p><h3 id="모델"><a href="#모델" class="headerlink" title="모델"></a>모델</h3>    <figure title="모델 구조와 표현 관계">      <a href="/images/create-the-undo-redo-feature/undo-redo.01.png" target="_blank">        <img           src="/images/create-the-undo-redo-feature/undo-redo.01.png"           alt="모델 구조와 표현 관계"           style=""        >      </a>      <figcaption>&lt;모델 구조와 표현 관계&gt;</figcaption>    </figure>  <p>모델은 <code>Shape</code>와 이를 상속받는 <code>Circle</code>, <code>Square</code>, <code>Triangle</code>이 있고 <code>Shape</code>를 관리하는 컬렉션 객체 <code>Shapes</code>가 있다. <code>Shapes</code>는 <code>Shape</code>를 관리할 뿐만 아니라 <code>Shape</code>에 대한 상태 변경도 담당한다. 즉, 이벤트 핸들러에서 <code>Shape</code>의 상태를 변경하고 싶은 경우 <code>Shapes</code>에 위임한다. </p><p>이렇게 작성한 이유는 변경에 대한 통지를 <code>Shapes</code>에서 총괄하기 위해서다. 표현은 <code>Shapes</code>만 구독하면 되기 때문에 단순하게 구현할 수 있다. 이 방법이 낯설지 모르겠지만 필자는 현 예제 규모에 잘 어울린다고 생각했다.</p><h3 id="표현"><a href="#표현" class="headerlink" title="표현"></a>표현</h3><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> bind<span class="token punctuation">,</span> wire <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'https://dev.jspm.io/hyperhtml/esm'</span><span class="token punctuation">;</span><span class="token operator">...</span><span class="token keyword">const</span> graphic <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.graphic'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> render <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span>graphic<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> shapes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Shapes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  render<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">    &lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">       ...     &lt;/svg>  </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>shapes<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span>update<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>이어서 <code>update()</code>를 살펴보자. 이 함수는 모델을 토대로 UI를 렌더링하는 즉, 표현을 위한 함수다. 표현에는 <a href="https://github.com/WebReflection/hyperHTML">hyperHTML</a>을 사용했다. hyperHTML은 Template literal 문법으로 UI를 만들 수 있는 작고 가벼운 라이브러리다. </p><p>먼저 <code>update()</code>를 호출해 SVG를 렌더링한다. 그리고 <code>shapes.on()</code>에 <code>update()</code>를 등록한다. 이로써 모델에 어떠한 변경이 있을 때마다 <code>update()</code>가 호출돼 자동으로 UI가 갱신된다.   </p><h3 id="이벤트-핸들러"><a href="#이벤트-핸들러" class="headerlink" title="이벤트 핸들러"></a>이벤트 핸들러</h3><pre class="language-js" data-language="js"><code class="language-js">addCircle<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token function">create</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> Circle<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>addSquare<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token function">create</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> Square<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>addTriangle<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token function">create</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> Triangle<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>remove<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span> <span class="token operator">...</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// ... 중략 ...</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'ontouchstart'</span> <span class="token keyword">in</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  docEl<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'touchstart'</span><span class="token punctuation">,</span> handlePointerStart<span class="token punctuation">)</span><span class="token punctuation">;</span>  docEl<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'touchmove'</span><span class="token punctuation">,</span> handlePointerMove<span class="token punctuation">)</span><span class="token punctuation">;</span>  docEl<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'touchend'</span><span class="token punctuation">,</span> handlePointerEnd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  docEl<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'mousedown'</span><span class="token punctuation">,</span> handlePointerStart<span class="token punctuation">)</span><span class="token punctuation">;</span>  docEl<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'mousemove'</span><span class="token punctuation">,</span> handlePointerMove<span class="token punctuation">)</span><span class="token punctuation">;</span>  docEl<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'mouseup'</span><span class="token punctuation">,</span> handlePointerEnd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>마지막으로 이벤트 핸들러를 살펴보자. 이벤트 핸들러는 도형을 추가하거나 삭제하는 버튼과 끌어다 놓을 수 있도록 <code>documentElement</code>에 등록하고 구현했다. </p><p>여기에서는 이벤트 핸들러의 구체적인 부분까지 설명하지 않는다. 하지만 다음 절을 원활히 이해하기 위해 이벤트 핸들러를 통해 어떻게 모델을 변경하고 있는지 한번 살펴보길 바란다. </p><h2 id="구현하기"><a href="#구현하기" class="headerlink" title="구현하기"></a>구현하기</h2><p>실행 취소 / 다시 실행을 구현하는 방법에는 크게 복사본(snapshot)을 저장하는 방식과 명령(command)을 저장하는 방식이 있다. 여기에서는 복사본을 저장하는 방식을 사용한다.</p><p>복사본을 저장하는 방식이란 모델의 상태를 JSON이나 플레인 자바스크립트 객체 형태로 저장해 두었다가 필요할 때 되돌리는 방법을 말한다. 이때 모델을 JSON이나 플레인 자바스크립트 객체 형태로 변환하는 과정을 직렬화(serialize)라고 하며, 복사본을 다시 본래의 모델로 되돌리는 것을 역직렬화(deserialize)라고 한다.</p><h3 id="serializr-소개"><a href="#serializr-소개" class="headerlink" title="serializr 소개"></a>serializr 소개</h3><p>모델(객체)의 상태를 직렬화 또는 역직렬화 하기 위해선 추가적인 작업이 필요하다. 예를 들어 객체에 <code>toJSON()</code>을 추가하고 객체 관계를 순회하여 플레인 자바스크립트 객체를 만들 수 있다. 그리고 생성한 플레인 자바스크립트 객체를 다시 순회하면서 적절한 생성자를 찾아 본래의 모델로 되돌릴 수 있다. </p><p>글로 설명하면 단순하지만 사실 꽤 따분한 작업이다. 또, 협업 개발자 모두가 이해할 수 있는 적절한 구조를 설계하기도 쉽지 않다. </p><p>이 역할을 충실히 수행하는 자바스크립트 라이브러리가 바로 <a href="https://github.com/mobxjs/serializr">serializr</a>다. serializr는 <a href="https://github.com/mobxjs/mobx">Mobx</a>의 서드 파티 라이브러리지만 그렇다고 Mobx를 의존하진 않는다. 따라서 다른 환경에서도 무리 없이 사용할 수 있다.</p><h3 id="모델-수정"><a href="#모델-수정" class="headerlink" title="모델 수정"></a>모델 수정</h3><p>그럼 모델을 serialzr를 이용해 직렬화 가능하게 수정해보자.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> serializr <span class="token keyword">from</span> <span class="token string">'https://dev.jspm.io/serializr'</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token punctuation">&#123;</span> createModelSchema<span class="token punctuation">,</span> serialize<span class="token punctuation">,</span> deserialize<span class="token punctuation">,</span> primitive<span class="token punctuation">,</span> list <span class="token punctuation">&#125;</span> <span class="token operator">=</span> serializr<span class="token punctuation">;</span></code></pre><p>먼저 serializr를 불러오고 구현에 사용할 함수를 몇 개 추린다.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Shape</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">data <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">...</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>posX <span class="token operator">=</span> posX<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>posY <span class="token operator">=</span> posY<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>tempX <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>tempY <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>fill <span class="token operator">=</span> fill<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>selected <span class="token operator">=</span> selected<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token operator">...</span><span class="token punctuation">&#125;</span></code></pre><p><code>Shape</code>는 <code>posX</code>, <code>posY</code>, <code>tempX</code>, <code>tempY</code>, <code>fill</code>, <code>selected</code> 속성을 가지고 있다. 이때 직렬화가 필요한 속성은 <code>posX</code>, <code>posY</code>, <code>fill</code>, <code>selected</code>다. <code>tempX</code>, <code>tempY</code>는 도형을 끄는 동안에 사용할 임시 값으로 실행 취소 / 다시 실행을 위해 따로 복사하지 않는다.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token function">createModelSchema</span><span class="token punctuation">(</span>Shape<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>  posX<span class="token operator">:</span> <span class="token function">primitive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  posY<span class="token operator">:</span> <span class="token function">primitive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  fill<span class="token operator">:</span> <span class="token function">primitive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  selected<span class="token operator">:</span> <span class="token function">primitive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>직렬화할 속성을 정했으면 serializr의 <code>createModelSchema()</code>를 사용해서 스키마를 정의한다. 이렇게 정의한 스키마는 추후 직렬화 시 사용된다. </p>    <div class="alert alert--info">              <strong class="alert__title">          스키마를 정의하는 법        </strong>            <div class="alert__body">        <p>여기에서는 <code>createModelSchema()</code>를 사용하지만, decorator를 이용해 보다 깔끔하게 스키마를 정의할 수도 있다. 자세한 내용은 serializr 저장소를 참고한다.</p>      </div>    </div>  <pre class="language-js" data-language="js"><code class="language-js"><span class="token function">createModelSchema</span><span class="token punctuation">(</span>Circle<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>  cx<span class="token operator">:</span> <span class="token function">primitive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  cy<span class="token operator">:</span> <span class="token function">primitive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  r<span class="token operator">:</span> <span class="token function">primitive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">createModelSchema</span><span class="token punctuation">(</span>Square<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>  x<span class="token operator">:</span> <span class="token function">primitive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  y<span class="token operator">:</span> <span class="token function">primitive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  width<span class="token operator">:</span> <span class="token function">primitive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  height<span class="token operator">:</span> <span class="token function">primitive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">createModelSchema</span><span class="token punctuation">(</span>Triangle<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>  points<span class="token operator">:</span> <span class="token function">list</span><span class="token punctuation">(</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token function">primitive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>이어서 <code>Shape</code>와 같은 방법으로 <code>Circle</code>, <code>Square</code>, <code>Triangle</code>에 대한 스키마를 정의한다. 그리고 <code>Shapes</code>에 객체의 상태를 복사할 수 있는 메서드와 복사본을 다시 되돌릴 수 있는 메서드를 추가한다.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Shapes</span> <span class="token punctuation">&#123;</span>  <span class="token operator">...</span>  <span class="token function">snapshot</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_shapes<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">restore</span><span class="token punctuation">(</span><span class="token parameter">dump</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_shapes <span class="token operator">=</span> dump<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> Shape <span class="token operator">=</span> <span class="token operator">??</span><span class="token operator">?</span><span class="token punctuation">;</span> <span class="token comment">/* 생성자를 알 수 없다 */</span>    <span class="token function">deserialize</span><span class="token punctuation">(</span>Shape<span class="token punctuation">,</span> data<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><code>Shapes</code>에 <code>snapshot()</code>과 <code>restore()</code>를 추가했다. 각 메서드에서 사용하는 <code>serialize()</code>와 <code>deserialize()</code>는 serializr에서 제공하는 함수다.</p><p><code>snapshot()</code>은 간단하다. <code>_shapes</code>를 <code>serialize()</code>에 전달하기만 하면 된다. 그러면 serializr는 앞서 정의한 스키마를 토대로 플레인 자바스크립트 객체를 반환할 것이다.</p><p>하지만 <code>restore()</code>는 그렇지 않다. <code>deserialize()</code>의 첫 번째 인자로는 역직렬화 할 객체 생성자, 두 번째 인자엔 되돌릴 객체 상태를 전달해야 하는데 복사본만으로는 연관된 생성자를 알 수 없다. 이 문제를 해결하기 위해서 모델을 다음과 같이 수정한다.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> ShapeType <span class="token operator">=</span> <span class="token punctuation">&#123;</span>   Circle<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>   Square<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>   Triangle<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>우선 enum으로 사용할 <code>ShapeType</code> 객체를 추가한다. <code>ShapeType</code>은 <code>Circle</code>, <code>Square</code>, <code>Triangle</code>을 식별할 수 있는 값을 정수로 갖는다.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Shape</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">data <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">...</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>shapeType <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token operator">...</span><span class="token punctuation">&#125;</span>Shape<span class="token punctuation">.</span>shapeType <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Circle</span> <span class="token keyword">extends</span> <span class="token class-name">Shape</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">data <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token operator">...</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>shapeType <span class="token operator">=</span> ShapeType<span class="token punctuation">.</span>Circle<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>Circle<span class="token punctuation">.</span>shapeType <span class="token operator">=</span> ShapeType<span class="token punctuation">.</span>Circle<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Square</span> <span class="token keyword">extends</span> <span class="token class-name">Shape</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">data <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token operator">...</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>shapeType <span class="token operator">=</span> ShapeType<span class="token punctuation">.</span>Square<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>Square<span class="token punctuation">.</span>shapeType <span class="token operator">=</span> ShapeType<span class="token punctuation">.</span>Square<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Triangle</span> <span class="token keyword">extends</span> <span class="token class-name">Shape</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">data <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">...</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>shapeType <span class="token operator">=</span> ShapeType<span class="token punctuation">.</span>Triangle<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>Triangle<span class="token punctuation">.</span>shapeType <span class="token operator">=</span> ShapeType<span class="token punctuation">.</span>Triangle<span class="token punctuation">;</span></code></pre><p>이어서 각 모델에 <code>shapeType</code> 속성을 추가하고 연관된 <code>ShapeType</code>을 대입한다. 이렇게 추가한 속성을 이용하면 연관된 생성자를 알 수 있다.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">getShapeClass</span><span class="token punctuation">(</span><span class="token parameter">shapeType</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">[</span> Circle<span class="token punctuation">,</span> Square<span class="token punctuation">,</span> Triangle <span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">C</span></span> <span class="token operator">=></span> <span class="token constant">C</span><span class="token punctuation">.</span>shapeType <span class="token operator">===</span> shapeType<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><code>getShapeClass()</code>은 <code>shapeType</code> 인자를 이용해 해당하는 생성자를 반환한다. 이 함수를 사용해 <code>Shapes</code>의 <code>restore()</code>를 다음과 같이 수정한다.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Shapes</span> <span class="token punctuation">&#123;</span>  <span class="token operator">...</span>  <span class="token function">snapshot</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_shapes<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">restore</span><span class="token punctuation">(</span><span class="token parameter">snapshot</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_shapes <span class="token operator">=</span> snapshot<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">d</span> <span class="token operator">=></span> <span class="token function">deserialize</span><span class="token punctuation">(</span><span class="token function">getShapeClass</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>shapeType<span class="token punctuation">)</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>이것으로 필요한 모델 수정은 모두 끝났다. 다음으로 실행 취소 / 다시 실행의 상태를 보관할 <code>History</code> 객체를 작성해보자.</p><h3 id="History-작성"><a href="#History-작성" class="headerlink" title="History 작성"></a>History 작성</h3><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">History</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">shapes</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_undoStack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_redoStack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_shapes <span class="token operator">=</span> shapes<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> snapshot <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_shapes<span class="token punctuation">.</span><span class="token function">snapshot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_undoStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>snapshot<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_redoStack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">undo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_undoStack<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> dump <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_undoStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">const</span> snapshot <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_shapes<span class="token punctuation">.</span><span class="token function">snapshot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>_redoStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>snapshot<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>_shapes<span class="token punctuation">.</span><span class="token function">restore</span><span class="token punctuation">(</span>dump<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">redo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_redoStack<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> dump <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_redoStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">const</span> snapshot <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_shapes<span class="token punctuation">.</span><span class="token function">snapshot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>_undoStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>snapshot<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>_shapes<span class="token punctuation">.</span><span class="token function">restore</span><span class="token punctuation">(</span>dump<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><code>History</code>는 실행 취소 / 다시 실행 시 필요한 상태를 관리하고 실행하는 역할을 한다. </p><p><code>take()</code>는 <code>shapes</code>를 통해 현재 상태를 가져와 실행 취소 스택에 추가하고 다시 실행 스택을 비운다. 이 메서드는 모델의 상태가 변경되기 직전에 호출돼야 한다. </p><p><code>undo()</code>는 실행 취소 스택에서 전 상태를 하나 꺼내오는 동시에 <code>shapes</code>에서 현재 상태를 가져온다. 그리고 다시 실행 스택에 현재 상태를 추가하고 <code>shapes.restore()</code>에 전 상태를 전달해 상태를 되돌린다.</p><p><code>redo()</code>는 다시 실행 스택에서 앞 상태를 하나 꺼내오는 동시에 <code>shapes</code>에서 현재 상태를 가져온다. 그리고 실행 취소 스택에 현재 상태를 추가하고 <code>shapes.restore()</code>에 앞 상태를 전달해 상태를 되돌린다.</p>    <div class="alert alert--info">              <strong class="alert__title">          메멘토 패턴        </strong>            <div class="alert__body">        <figure title="메멘토 패턴">  <a href="/images/2019/create-the-undo-redo-feature/undo-redo.02.png" target="_blank">    <img       src="/images/2019/create-the-undo-redo-feature/undo-redo.02.png"       alt="메멘토 패턴"       style=""    >  </a></figure><p>이미 눈치챈 사람도 있겠지만 이것은 메멘토 패턴이다. 메멘토 패턴은 <code>Originator</code>에서 <code>Memento</code>(상태)를 가져와 <code>Cretaker</code>에 저장하고 추후 다시 꺼내 <code>Originator</code>에 전달하여 상태를 되돌리는 패턴을 말한다(<a href="https://ko.wikipedia.org/wiki/%EB%A9%94%EB%A9%98%ED%86%A0_%ED%8C%A8%ED%84%B4">참고</a>).</p>      </div>    </div>  <p>이것으로 실행 취소 / 다시 실행을 위한 모든 준비를 마쳤다. 이제 각 이벤트 핸들러에서 필요에 따라 <code>History</code> 객체를 호출해주면 된다.</p><h3 id="이벤트-핸들러-수정"><a href="#이벤트-핸들러-수정" class="headerlink" title="이벤트 핸들러 수정"></a>이벤트 핸들러 수정</h3><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> shapes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Shapes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> history <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">History</span><span class="token punctuation">(</span>shapes<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>먼저 <code>shapes</code>를 생성한 후 이를 주입해 <code>history</code>를 생성한다.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token parameter">Shape</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  history<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 추가</span>  <span class="token keyword">const</span> shape <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Shape</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>     posX<span class="token operator">:</span> <span class="token function">random</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">,</span>     posY<span class="token operator">:</span> <span class="token function">random</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  shapes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">;</span>  shapes<span class="token punctuation">.</span><span class="token function">selectOne</span><span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>이어서 도형 생성 시 호출되는 <code>create()</code>를 살펴보자. 새로운 도형을 생성하기 전에 <code>history.take()</code>를 호출하여 현재 상태를 저장하도록 수정한다.</p><pre class="language-js" data-language="js"><code class="language-js">remove<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> shape <span class="token operator">=</span> shapes<span class="token punctuation">.</span><span class="token function">getSelected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>shape<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    history<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 추가</span>    shapes<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <p>삭제도 마찬가지로 도형을 삭제하기 전 <code>history.take()</code>를 호출하여 현재 상태를 저장하도록 수정한다.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">handlePointerEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>dragging <span class="token operator">&amp;&amp;</span> shape<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>shape<span class="token punctuation">.</span>tempX <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      history<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 추가  </span>    <span class="token punctuation">&#125;</span>    shapes<span class="token punctuation">.</span><span class="token function">arrive</span><span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">;</span>    dragging <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    shape <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><code>handlePointerEnd()</code>는 도형을 끌어다 놓는 시점(<code>mouseup</code> 또는 <code>touchend</code>)에 호출되는 이벤트 핸들러다. <code>shape</code>에 저장된 임시 위칫값이 적용되기 전에 <code>history.take()</code>를 호출하여 현재 상태를 저장하도록 수정한다. </p><p>만약 도형을 끄는 시점(<code>mousemove</code> 또는 <code>touchmove</code>)에 <code>posX</code>, <code>posY</code>의 값을 수정하면 <code>history.take()</code>를 호출할 때 이미 값이 변경돼 전 상태를 보관할 수 없다. 이것이 <code>tempX</code>, <code>tempY</code>를 사용하는 이유다.</p><pre class="language-js" data-language="js"><code class="language-js">undo<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> history<span class="token punctuation">.</span><span class="token function">undo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>redo<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> history<span class="token punctuation">.</span><span class="token function">redo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>마지막으로 실행 취소 / 다시 실행 버튼을 추가하고 각 이벤트 핸들러에 <code>history</code>의 <code>undo()</code>, <code>redo()</code>가 호출되도록 작성한다. </p><h3 id="결과"><a href="#결과" class="headerlink" title="결과"></a>결과</h3><p>처음에 소개한 예제를 기반으로 차근차근 코드를 수정했다면 다음과 같이 실행 취소 / 다시 실행 기능이 적용된 애플리케이션이 완성될 것이다.</p>    <p data-height="300" data-theme-id="0" data-slug-hash="VJMOxp" data-default-tab="result" data-user="uyeong" data-embed-version="2" data-pen-title="VJMOxp" class="codepen">      See the Pen <a href="http://codepen.io/uyeong/pen/VJMOxp/">VJMOxp</a> by Uyeong Ju (<a href="http://codepen.io/uyeong">@uyeong</a>) on <a href="http://codepen.io">CodePen</a>.    </p>  <h2 id="끝으로"><a href="#끝으로" class="headerlink" title="끝으로"></a>끝으로</h2><p>여기까지 <code>serializr</code>를 활용해 손쉽게 실행 취소 / 다시 실행을 구현해봤다. 물론 이 방식을 실제 제품에 사용하기 위해선 다양한 측면에서의 테스트가 필요할 것이다. 하지만 원리 자체에 큰 차이가 없으므로 기능을 구현하는 데 있어 도움이 될 것으로 생각한다.</p>]]></content>
    
    
    <summary type="html">실행 취소 / 다시 실행(Undo/Redo) 기능을 어떻게 구현할 수 있는지 자바스크립트 라이브러리 serializr와 함께 단계별로 자세히 설명합니다.</summary>
    
    
    
    <category term="JavaScript" scheme="http://blog.coderifleman.com/categories/JavaScript/"/>
    
    <category term="Implementation" scheme="http://blog.coderifleman.com/categories/JavaScript/Implementation/"/>
    
    
    <category term="Development" scheme="http://blog.coderifleman.com/tags/Development/"/>
    
    <category term="JavaScript" scheme="http://blog.coderifleman.com/tags/JavaScript/"/>
    
    <category term="Architecture" scheme="http://blog.coderifleman.com/tags/Architecture/"/>
    
    <category term="Undo/Redo" scheme="http://blog.coderifleman.com/tags/Undo-Redo/"/>
    
  </entry>
  
  <entry>
    <title>백엔드 개발자와 협업하는 두 가지 방법</title>
    <link href="http://blog.coderifleman.com/2018/03/03/two-ways-to-work-with-backend-developer/"/>
    <id>http://blog.coderifleman.com/2018/03/03/two-ways-to-work-with-backend-developer/</id>
    <published>2018-03-02T15:00:00.000Z</published>
    <updated>2022-11-09T05:45:21.014Z</updated>
    
    <content type="html"><![CDATA[<p>보통 애플리케이션 개발은 외부 자원에 접근할 수 있는 API가 필요하다. 그리고 대개, API를 개발하는 백엔드 개발자와 애플리케이션 인터페이스를 개발하는 프런트엔드 개발자로 나눠 협업한다. 이때 두 직군 간 협업 과정에서 병목이 발생하기 쉽다.</p><p>프런트엔드 개발자는 동작하는 API를 기다리고 백엔드 개발자는 프런트엔드 요구에 맞춰 API, 또는 비즈니스 로직까지 변경해야 하는 일이 생긴다. 그러다 보니 교착 상태에 빠지거나 시간이 흐를수록 커뮤니케이션이 힘들어지기도 한다.</p><p>만약 당신이 이러한 문제를 겪고 있다면 지금부터 소개하는 두 가지 방법이 도움이 될 수 있다.</p><h2 id="API-인터페이스-협의"><a href="#API-인터페이스-협의" class="headerlink" title="API 인터페이스 협의"></a>API 인터페이스 협의</h2><p>가장 이상적인 방법은 API 인터페이스를 협의하는 과정을 갖는 것이다. 필요한 API는 요구사항 분석 과정에서 알 수 있다. 예를 들어 복수의 피드를 선택해 구독하는 기능을 떠올려보자. 자연스럽게 복수 피드에 대해 구독 요청을 할 수 있는 API가 필요함을 알 수 있다.</p><p>이어서 백엔드 개발자와 함께 구독 요청 API 인터페이스를 협의한다. API 인터페이스란 어떤 메서드와 URL로 요청 해야 하고 응답 형식은 무엇인가에 대한 약속이다. 이를 신뢰하고 각자 개발을 진행한다. 동작하는 API를 기다리지 않아도 된다.</p><p><a href="https://nodejs.org/en/">Node.js</a>에 익숙하다면 <a href="https://expressjs.com/">Express</a>를 이용해 목서버를 만들 수 있다. 만약 테스트를 작성한다면 <a href="http://sinonjs.org/">Sinon.JS</a>의 <a href="http://sinonjs.org/releases/v4.4.2/fake-xhr-and-server/">Fake XHR</a>을 이용한다.</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'collect()'</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token comment">// Given</span>  server<span class="token punctuation">.</span><span class="token function">respondWith</span><span class="token punctuation">(</span><span class="token string">'POST'</span><span class="token punctuation">,</span> <span class="token operator">/</span>\\<span class="token operator">/</span>api\\<span class="token operator">/</span>feeds\\<span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">collect</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span> <span class="token parameter">xhr</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>requestBody<span class="token punctuation">)</span><span class="token punctuation">.</span>productIds <span class="token operator">!==</span> <span class="token string">'1,2,3'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    xhr<span class="token punctuation">.</span><span class="token function">respond</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token string">'Content-Type'</span><span class="token operator">:</span> <span class="token string">'application/json'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>collectId<span class="token operator">:</span> <span class="token string">'ab8d7ee'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// When</span>  <span class="token keyword">const</span> collectId <span class="token operator">=</span> <span class="token keyword">await</span> feeds<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Then</span>  <span class="token function">expect</span><span class="token punctuation">(</span>collectId<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span><span class="token string">'ab8d7ee'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>또는, 목서버 없이 개발 환경에서만 <a href="http://sinonjs.org/releases/v4.4.2/fake-xhr-and-server/">Fake XHR</a>을 애플리케이션 문맥에 불러올 수도 있다.</p><h2 id="팩토리를-이용한-개발"><a href="#팩토리를-이용한-개발" class="headerlink" title="팩토리를 이용한 개발"></a>팩토리를 이용한 개발</h2><p>어떠한 API가 필요하고 또, 구현 가능한지 불확실할 때는 협의 미팅이 도움 되지만, 구현할 기능이 단순하고 필요한 API에 관해 대략적인 정보를 공유하고 있다면 오히려 비용일 수 있다. 그렇지만 API 응답 형태를 모르는 상태에서 예측으로 코드를 작성하면 통합 단계에서 애플리케이션 전체의 코드 변경이 필요할 수 있다.</p><p>친구 목록을 가져와 출력해주는 기능을 상상해보자. 이 요구사항에서 모델을 디자인할 수 있다.</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">FriendEntity</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">readonly</span> id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">readonly</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">readonly</span> tel<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>  <span class="token keyword">constructor</span><span class="token punctuation">(</span>data<span class="token operator">:</span> Friend<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> data<span class="token punctuation">.</span>id<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> data<span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>tel <span class="token operator">=</span> data<span class="token punctuation">.</span>tel<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>이 모델을 의존해 기능을 개발한다. API의 응답은 몰라도 된다. 이후 동작하는 API를 전달받았는데 응답 형태가 앞서 작성한 모델과 다르다고 가정해보자.</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">FriendPayload</span> <span class="token punctuation">&#123;</span>  userNo<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>  phoneNumber<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>만약 모델을 바꾸면 애플리케이션에 영향이 생긴다. 그리고 외부 데이터가 모델의 변경을 유발한다는 것도 논리적이지 않다. 이때, 우리는 팩토리 객체를 이용할 수 있다.</p><pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">FriendFactory</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token function">create</span><span class="token punctuation">(</span>data<span class="token operator">:</span> FriendPayload<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FriendEntity</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>      id<span class="token operator">:</span> data<span class="token punctuation">.</span>userNo<span class="token punctuation">,</span>      name<span class="token operator">:</span> data<span class="token punctuation">.</span>name<span class="token punctuation">,</span>      tel<span class="token operator">:</span> data<span class="token punctuation">.</span>phoneNumber    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>me<span class="token punctuation">.</span><span class="token function">friends</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token operator">:</span> FriendPayload<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> friends <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>d <span class="token operator">=></span> FriendFactory<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  friendListView<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>friendListView</code>는 <code>FriendEntity</code>에 의존한다. API의 응답 형태로 인해 <code>friendListView</code>가 영향받지 않는다. 이처럼 모델에서 시작하고, 모델을 의존하면 API 없이 개발을 시작할 수 있다. API를 전달받으면 팩토리 객체를 이용해 변경을 최소화하고 통합하면 된다.</p><p>여기까지 백엔드 개발자와 협업하는 두 가지 방법을 간단히 소개했다. 어떠한 API가 필요하고 또, 구현 가능한지 불확실하다면 API 인터페이스 협의 과정을 갖길 바란다. 하지만 기능이 단순하고 필요한 API도 어느 정도 공유된 상황에서 협의 미팅은 피곤할 수 있다. 그땐 팩토리 객체를 이용하자. 애플리케이션의 변경을 최소화해 개발할 수 있다.</p>]]></content>
    
    
    <summary type="html">이 문서는 백엔드 개발자와 협업하는 두 가지 방법을 정리한 문서로 API 협의 과정 또는 그러한 과정없이 애플리케이션을 개발하는 방법을 소개합니다.</summary>
    
    
    
    <category term="Development" scheme="http://blog.coderifleman.com/categories/Development/"/>
    
    
    <category term="Development" scheme="http://blog.coderifleman.com/tags/Development/"/>
    
    <category term="JavaScript" scheme="http://blog.coderifleman.com/tags/JavaScript/"/>
    
    <category term="Sinon.js" scheme="http://blog.coderifleman.com/tags/Sinon-js/"/>
    
    <category term="TypeScript" scheme="http://blog.coderifleman.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>The Clean Architecture</title>
    <link href="http://blog.coderifleman.com/2017/12/18/the-clean-architecture/"/>
    <id>http://blog.coderifleman.com/2017/12/18/the-clean-architecture/</id>
    <published>2017-12-17T15:00:00.000Z</published>
    <updated>2022-11-09T05:45:21.014Z</updated>
    
    <content type="html"><![CDATA[    <div class="alert alert--info">              <strong class="alert__title">          읽기전에...        </strong>            <div class="alert__body">        <p>이 문서는 일본어 「<a href="https://blog.tai2.net/the_clean_architecture.html">クリーンアーキテクチャ(The Clean Architecture翻訳)</a>」을 중역한 글입니다. 원글은 「<a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html">The Clean Architecture</a>」로 번역 시 참고했습니다. 오역 감수는 프런트엔드 개발자 <a href="https://github.com/DuYongLee">이두용</a>님께서 수고해주셨습니다.</p>      </div>    </div>  <p><a href="https://twitter.com/unclebobmartin">로버트 C. 마틴(Robert Martin, a.k.a 엉클 아저씨)</a>이 공개한 「<a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html">The Clean Architecture</a>」를 번역한 글입니다. 관점이 비슷한 「<a href="https://blog.tai2.net/hexagonal_architexture.html">Hexagonal Architecture</a>(일본어)」도 번역했으니 참고해주세요.</p><p>해당 글을 번역하겠다고 「<a href="https://8thlight.com/">8th Light, inc</a>」에 이야기했으며 현재까지는 별다른 제재가 없었습니다.</p>    <figure title="The Clean Architecture의 다이어그램">      <a href="/images/the-clean-architecture/the-clean-architecture.jpg" target="_blank">        <img           src="/images/the-clean-architecture/the-clean-architecture.jpg"           alt="The Clean Architecture의 다이어그램"           style=""        >      </a>      <figcaption>&lt;그림. The Clean Architecture의 다이어그램&gt;</figcaption>    </figure>  <p>지난 몇 년 동안 우리는 시스템 아키텍처에 대한 실로 다양한 아이디어를 봐왔다. 예를들어 다음과 같은 것이 포함된다.</p><ul><li>알리스테어 코번(Alistair Cockburn)의 <a href="http://alistair.cockburn.us/Hexagonal+architecture">헥사고날 아키텍처(Hexagonal Architecture, a.k.a Ports and Adapters)</a>. 스티브 프리먼(Steve Freeman)과 냇 프라이스(Nat Pryce)의 훌륭한 책 <a href="http://www.yes24.com/24/goods/9008455?scode=032&OzSrank=1">테스트 주도 개발로 배우는 객체 지향 설계와 실천(Growing Object-Oriented Software)</a>에서 차용.</li><li>제프리 팔레모르(Jeffrey Palermo)의 <a href="http://jeffreypalermo.com/blog/the-onion-architecture-part-1/">어니언 아키텍쳐(Onion Architecture)</a></li><li>작년, 블로그에 포스팅한 <a href="https://8thlight.com/blog/uncle-bob/2011/09/30/Screaming-Architecture.html">스크리밍 아키텍쳐(Screaming Architecture)</a></li><li>트리그베 린스카그(Trygve Reenskaug)와 제임스 코플리엔(James Coplien)의 <a href="https://www.amazon.com/Lean-Architecture-Agile-Software-Development/dp/0470684208/">DCI</a></li><li>이바르 제이콥슨(Ivar Jacobson)의 <a href="https://www.amazon.com/Object-Oriented-Software-Engineering-Approach/dp/0201544350">BCE</a>, 그의 저서 Object Oriented Software Engineering: A Use-Case Driven Approach에서.</li></ul><p>위 아키텍처의 세세한 부분은 모두 다르지만 매우 비슷하기도 하다. 이들은 모두 같은 목적을 갖고 있는데 바로 관심사의 분리다. 소프트웨어를 계층으로 나눔으로써 관심사를 분리한다. 그리고 모두 비즈니스 규칙을 위한 최소 하나 이상의 계층과 인터페이스를 위한 또 다른 계층을 두고 있다.</p><p>위 아키텍처 모두는 다음과 같은 시스템을 생성한다.</p><ol><li>프레임워크 독립적, 이들 아키텍처는 소프트웨어 라이브러리 존재 여부에 의존하지 않는다. 이는 시스템을 프레임워크의 한정된 제약에 억지로 집어넣는 대신 도구로써 사용하는 것을 가능하게 한다.</li><li>테스트 용이함, 비즈니스 규칙은 UI, 데이터베이스, 웹 서버, 기타 외부 요인없이 테스트 가능하다.</li><li>UI 독립적, 시스템의 나머지 부분을 변경할 필요 없이 UI를 쉽게 변경할 수 있다. 예를들면 웹 UI는 비즈니스 규칙 변경 없이 콘솔 UI와 치환된다.</li><li>데이터베이스 독립적, 오라클 또는 SQL Server를 몽고, 빅테이블, 카우치 DB 등으로 바꿀 수 있다. 비즈니스 규칙은 데이터베이스에 얽매이지 않는다.</li><li>외부 기능 독립적, 실제로 비즈니스 규칙은 외부 세계에 대해 아무것도 모른다.</li></ol><p>이 문서의 말머리에 소개한 그림은 이러한 아키텍처를 단일 개념으로 통합하고자 하는 시도다.</p><h2 id="의존-규칙"><a href="#의존-규칙" class="headerlink" title="의존 규칙"></a>의존 규칙</h2><p>이들 동심원은 소프트웨어의 각기 다른 영역을 나타내고 있다. 대개, 바깥쪽으로 향할수록 고수준의 소프트웨어가 된다. 바깥쪽의 원은 메커니즘(Mechanism)이고 안쪽의 원은 정책(Policy)이다.</p><p>이 아키텍처를 기능하게 하는 중요한 규칙이 바로 의존 규칙이다. 이 규칙에 의해서 소스 코드는 안쪽을 향해서만 의존할 수 있다. 안쪽의 원은 바깥쪽의 원에 대해 전혀 알지 못한다. 특히, 바깥쪽의 원에서 선언된 어떠한 이름을 안쪽 원에서 참조해서는 안된다. 이는 함수, 클래스, 변수 등 이름이 붙은 소프트웨어의 엔티티 모든 것에 해당한다.</p><p>마찬가지로 바깥쪽의 원에서 사용하고 있는 데이터 포맷을 안쪽의 원에서 사용하지 않아야 한다. 특히 그러한 포맷이 바깥쪽 원에서 프레임워크에 의해 생성되고 있다면 바깥쪽 원의 어떠한 것도 안쪽의 원에 영향을 줘선 안된다.</p><h2 id="엔티티"><a href="#엔티티" class="headerlink" title="엔티티"></a>엔티티</h2><p>엔티티는 대규모 프로젝트 레벨의 비즈니스 규칙을 캡슐화 한다. 엔티티는 메서드를 갖는 객체 일 수도 있지만 데이터 구조와 함수의 집합일 수도 있다. 엔티티가 대규모 프로젝트 내의 다양한 애플리케이션에서 사용된다고 하더라도 문제될 것은 없다.</p><p>대규모 프로젝트가 아닌 단지 하나의 애플리케이션을 작성할 뿐이라면 엔티티는 그 애플리케이션의 비즈니스 객체가 된다. 엔티티는 가장 일반적이면서 고수준의 규칙을 캡슐화한다. 그리고 바깥쪽에서 무엇이 변경되더라도 바뀌지 않는다. 예를들어 엔티티 객체는 페이지 내비게이션의 변경이나 보안 사항으로 부터 영향을 받지 않을 것을 기대할 수 있다. 애플리케이션의 동작에 관한 변경이 엔티티 계층에 영향을 주어선 안된다.</p><h2 id="유스케이스"><a href="#유스케이스" class="headerlink" title="유스케이스"></a>유스케이스</h2><p>이 계층의 소프트웨어는 애플리케이션 고유 비즈니스 규칙을 포함하며 시스템의 모든 유스케이스를 캡슐화하고 구현한다. 이들 유스케이스는 엔티티로 부터의 혹은 엔티티에서의 데이터 흐름을 조합한다. 그리고 엔티티 즉, 프로젝트 레벨의 비즈니스 규칙을 사용해 유스케이스의 목적을 달성하도록 지휘한다.</p><p>이 계층의 변경이 엔티티에 영향을 주지 않을 것을 기대하며 데이터베이스, UI 또는 공통의 프레임워크의 변경으로부터 영향 받지 않을 것도 기대한다. 이 계층은 그러한 관심에서 격리된다.</p><p>하지만, 애플리케이션의 조작에 대한 변경은 유스케이스에 영향이 있고 따라서 이 계층의 소프트웨어에 영향이 있을 것을 기대한다. 유스케이스의 상세가 바뀐다면 이 계층의 코드는 확실히 영향을 받는다.</p><h2 id="인터페이스-어댑터"><a href="#인터페이스-어댑터" class="headerlink" title="인터페이스 어댑터"></a>인터페이스 어댑터</h2><p>이 계층의 소프트웨어는 어댑터의 집합이다. 이는 유스케이스와 엔티티에 있어 용이한 형식으로부터 데이터베이스나 웹 등 외부의 기능에 용이한 형식으로 데이터를 변환한다. 예를들어 이 레이어는 GUI의 MVC 아키텍처를 완전히 내포한다. 프리젠터, 뷰, 컨트롤러는 모두 여기에 속한다. 모델은 컨트롤러에서 유스케이스로 전달되고 이어 유스케이스에서 프리젠터나 뷰로 되돌아가는 그저 단순한 데이터 구조일 가능성이 높다.</p><p>마찬가지로 이 계층에서 데이터는, 엔티티나 유스케이스에 용이한 형에서, 사용하고 있는 프레임워크에  용이한 형으로 변환된다. 예를들어 데이터베이스를 들 수 있다. 이 계층에 해당하는 원보다 안쪽에 존재하는 코드는 데이터베이스에 관해 아는 것이 없어야 한다. 만약 데이터베이스가 SQL 데이터베이스라면 어떤 SQL이든 이 계층에 제한돼야 하며 특히, 이 계층 내의 데이터베이스와 관련 있는 부분에 제한돼야 된다.</p><p>또, 이 계층에는 외부의 어떠한(외부 서비스) 형식에서 유스케이스와 엔티티에서 사용될 수 있는 내부 형식으로 데이터를 변환하기 위해 필요한 기타 모든 어댑터도 둘 수 있다.</p><h2 id="프레임워크와-드라이버"><a href="#프레임워크와-드라이버" class="headerlink" title="프레임워크와 드라이버"></a>프레임워크와 드라이버</h2><p>가장 바깥쪽의 계층은 데이터베이스나 웹 프레임워크 등 일반적으로 프레임워크나 도구로 구성된다. 대개, 이 계층에는 안쪽의 원과 통신할 연결 코드 이외에는 별다른 코드를 작성하지 않는다.</p><p>이 계층에는 상세한 정보가 무엇이든 여기에 둔다. 웹은 상세하다. 그리고 데이터베이스도 상세하다. 이러한 것으로 인해 악영향을 주지 않도록 밖에 유지한다.</p><h2 id="4개의-원이-아니면-안되는가"><a href="#4개의-원이-아니면-안되는가" class="headerlink" title="4개의 원이 아니면 안되는가"></a>4개의 원이 아니면 안되는가</h2><p>아니다. 이 원은 컨셉을 전하기 위한 수단이다. 이 4가지 이외에도 무엇인가 필요할 가능성이 있다. 정확히 4가지가 아니면 안된다는 규칙은 없다. 하지만 의존 규칙은 항상 적용된다. 소스 코드의 의존성은 항상 안쪽으로 향해야 한다. 안쪽으로 향해감에 따라 추상화 수준은 올라간다. 가장 바깥쪽의 원은 저수준의 구체적인 상세 정보를 담는다. 안쪽으로 이동해가면서 소프트웨어는 추상화 되고 고수준의 정책을 캡슐화한다. 가장 안쪽에 있는 원은 무엇보다 일반성이 있다.</p><h2 id="교차경계"><a href="#교차경계" class="headerlink" title="교차경계"></a>교차경계</h2><p>위 다이어그램의 오른쪽 아래의 그림은 어떤식으로 원의 경계가 교차하는지 보여주는 예다. 이것은 컨트롤러와 프리젠터가 다음 계층인 유스케이스와 어떻게 대화하는지 보여준다. 제어의 흐름에 주의하길 바란다. 컨트롤러에서 시작해 유스케이스를 거쳐 프리젠터에서 실행됨을 알 수 있다. 소스 코드의 의존성에도 주의한다. 모두 안쪽의 유스케이스를 향하고 있다.</p><p>우리는 이 분명한 모순을 <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">의존 관계 역전의 원칙(Dependency Inversion Principle)</a>으로 해결하는 경우가 많다. 예를들어 Java와 같은 언어에서는 인터페이스와 상속 관계를 조합해 소스 코드의 의존성이 경계를 걸치고 있는 오른쪽 지점에서 제어 흐름이 반대하도록 한다.</p><p>다시 예를들어 유스케이스가 프리젠터를 호출할 필요가 있는 경우를 생각해보자. 하지만 이때의 호출은 직접 이뤄질 수 없다. 왜냐하면 **”의존성 규칙 : 바깥쪽의 이름을 안쪽에서 언급할 수 없다”**를 위반하기 때문이다. 때문에 유스케이스에는 안쪽 원에 있는 인터페이스(Use Case Output Port라고 적혀있는)를 호출한다. 그리고 원 바깥쪽의 프리젠터는 이 인터페이스를 구현한다.</p><p>이와 똑같은 테크닉이 아키텍처의 경계가 교차되는 곳에서 사용된다. 동적인 다형성의 이점을 이용해 소스 코드의 의존성이 제어 흐름의 반대가 되도록 한다. 이렇게 하면 제어의 흐름이 어떤 방향으로 진행되든지 상관없이 의존성 규칙을 지킬 수 있다.</p><h2 id="어떤-데이터가-경계를-교차하는가"><a href="#어떤-데이터가-경계를-교차하는가" class="headerlink" title="어떤 데이터가 경계를 교차하는가"></a>어떤 데이터가 경계를 교차하는가</h2><p>대개, 경계를 넘나드는 데이터는 단순한 구조의 데이터다. 기본적인 구조체나 단순한 데이터 전송 객체(Data Transter Object)를 취향에 맞게 사용할 수 있다. 혹은 데이터는 단순히 함수의 인수라 해도 좋다. 또는, 그것을 해시맵으로 해도 좋고 객체로 구성해도 좋다. 중요한 것은 격리된 단순한 구조의 데이터가 경계를 넘어간다는 점이다. 우리는 꾀를 부려 엔티티나 데이터베이스의 행을 전달하지 않는다. 데이터 구조가 의존성 규칙을 위반하는 모든 종류의 원인을 갖지 않길 바란다.</p><p>예를 들어 여러 데이터베이스 프레임워크는 쿼리에 응답하여 편리한 데이터 포맷을 반환한다. 이것을 행 구조(RowStructure)라고 부르자. 이 행 구조를, 경계를 넘어 안쪽으로 전달하지 않기를 원한다. 이는 의존성 규칙을 위반한다. 왜냐하면 바깥쪽 원에 관한 무언가를 안쪽의 원이 알도록 강제하기 때문이다.</p><p>때문에 경계를 넘어 데이터를 전달할 때엔 항상 안쪽의 원이 다루기 쉬운 데이터 형식이어야 한다.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>이런 간단한 규칙을 따르는 것은 어렵지 않다. 그리고 머리가 아프지 않도록 도와 줄 것이다. 소프트웨어를 계층으로 나누고 의존성 규칙을 따름으로써 본질적으로 테스트하기 쉬운 시스템을 만들 수 있고 의존성 규칙이 가져오는 이점도 얻을 수 있다. 시스템의 외부 부품(데이터베이스나 웹 프레임워크 등)이 낡았다면 그러한 부분도 최소한의 노력으로 바꿀 수 있다.</p>]]></content>
    
    
    <summary type="html">이 문서는 로버트 C. 마틴의 The Clean Architecture를 한국어로 번역한 문서입니다. 그의 좋은 의도와 생각이 널리 전파되길 바랍니다</summary>
    
    
    
    <category term="Architecture" scheme="http://blog.coderifleman.com/categories/Architecture/"/>
    
    
    <category term="Architecture" scheme="http://blog.coderifleman.com/tags/Architecture/"/>
    
    <category term="MVC" scheme="http://blog.coderifleman.com/tags/MVC/"/>
    
  </entry>
  
  <entry>
    <title>Tabnabbing 공격과 rel=noopener 속성</title>
    <link href="http://blog.coderifleman.com/2017/05/30/tabnabbing_attack_and_noopener/"/>
    <id>http://blog.coderifleman.com/2017/05/30/tabnabbing_attack_and_noopener/</id>
    <published>2017-05-29T15:00:00.000Z</published>
    <updated>2022-11-09T05:45:21.014Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Tabnabbing"><a href="#Tabnabbing" class="headerlink" title="Tabnabbing"></a>Tabnabbing</h2><p>Tabnabbing이란 HTML 문서 내에서 링크(target이 _blank인 Anchor 태그)를 클릭 했을 때 새롭게 열린 탭(또는 페이지)에서 기존의 문서의 location을 피싱 사이트로 변경해 정보를 탈취하는 공격 기술을 뜻한다. 이 공격은 메일이나 오픈 커뮤니티에서 쉽게 사용될 수 있다.</p>    <figure title="Tabnabbing 공격 흐름">      <a href="/images/tabnabbing_attack_and_noopener/tab-nabbing.01.svg" target="_blank">        <img           src="/images/tabnabbing_attack_and_noopener/tab-nabbing.01.svg"           alt="Tabnabbing 공격 흐름"           style="max-width:420px"        >      </a>      <figcaption>&lt;그림 1. Tabnabbing 공격 흐름(<a href="https://blog.jxck.io/entries/2016-06-12/noopener.html">출처</a>)&gt;</figcaption>    </figure>  <p>공격 절차는 다음과 같다.</p><ol><li>사용자가 <code>cgm.example.com</code>에 접속한다.</li><li>해당 사이트에서 <code>happy.example.com</code>으로 갈 수 있는 외부 링크를 클릭한다.</li><li>새탭으로 <code>happy.example.com</code>가 열린다.</li></ol><ul><li><code>happy.example.com</code>에는 <code>window.opener</code> 속성이 존재한다.</li><li>자바스크립트를 사용해 opener의 location을 피싱 목적의 <code>cgn.example.com/login</code> 으로 변경한다.</li></ul><ol start="4"><li>사용자는 다시 본래의 탭으로 돌아온다.</li><li>로그인이 풀렸다고 생각하고 아이디와 비밀번호를 입력한다.</li></ol><ul><li><code>cgn.example.com</code>은 사용자가 입력한 계정 정보를 탈취한 후 다시 본래의 사이트로 리다이렉트한다.</li></ul><h2 id="NAVER-메일과-Gmail"><a href="#NAVER-메일과-Gmail" class="headerlink" title="NAVER 메일과 Gmail"></a>NAVER 메일과 Gmail</h2><p>시나리오를 하나 그려보자. 공격자가 네이버 계정을 탈취할 목적으로 여러분에게 바겐세일 정보를 담은 메일을 보냈다. 그 메일에는 [자세히 보기]라는 외부 링크가 포함돼 있다.</p><p>물론 이 바겐세일 정보는 가짜지만 공격자에겐 중요하지 않다. 메일을 읽는 사람이 유혹에 빠져 링크를 클릭하면 그만이다.</p>    <figure title="NAVER 메일을 이용한 Tabnabbing 데모">      <a href="/images/tabnabbing_attack_and_noopener/tab-nabbing.02.gif" target="_blank">        <img           src="/images/tabnabbing_attack_and_noopener/tab-nabbing.02.gif"           alt="NAVER 메일을 이용한 Tabnabbing 데모"           style="max-width:420px"        >      </a>      <figcaption>&lt;그림 2. NAVER 메일을 이용한 Tabnabbing 데모&gt;</figcaption>    </figure>  <p>국내에서 가장 유명한 포털 회사인 NAVER가 이러한 공격에 다소 미흡한 점은 못내 아쉽다. NAVER 뿐만 아니라 DAUM도 마찬가지이며 아마 카페 서비스도 동일하게 재현할 수 있지 않을까 생각한다.</p><p>하지만 Gmail은 이 공격이 통하지 않는다. Gmail은 이러한 공격을 막기 위해 Anchor 태그에 data-saferedirecturl 속성을 부여해 안전하게 리다이렉트 한다. Twitter도 동일한 방법으로 대응하고 있다.</p>    <figure title="Gmail의 소스 코드">      <a href="/images/tabnabbing_attack_and_noopener/tab-nabbing.03.png" target="_blank">        <img           src="/images/tabnabbing_attack_and_noopener/tab-nabbing.03.png"           alt="Gmail의 소스 코드"           style="max-width:420px"        >      </a>      <figcaption>&lt;그림 3. Gmail의 소스 코드&gt;</figcaption>    </figure>  <h2 id="rel-noopener-속성"><a href="#rel-noopener-속성" class="headerlink" title="rel=noopener 속성"></a>rel=noopener 속성</h2><p>이러한 공격의 취약점을 극복하고자 noopener 속성이 추가 됐다.</p><p>rel=noopener 속성이 부여된 링크를 통해 열린 페이지는 location 변경과 같은 자바스크립트 요청을 거부한다. 정확히 말해서 <code>Uncaught TypeError</code> 에러를 발생시킨다(크롬 기준).</p>    <figure title="새탭의 콘솔 결과">      <a href="/images/tabnabbing_attack_and_noopener/tab-nabbing.04.png" target="_blank">        <img           src="/images/tabnabbing_attack_and_noopener/tab-nabbing.04.png"           alt="새탭의 콘솔 결과"           style="max-width:420px"        >      </a>      <figcaption>&lt;그림 4. 새탭의 콘솔 결과&gt;</figcaption>    </figure>  <p>이 속성은 <a href="https://labs.jxck.io/noopener/">Window Opener Demo</a> 페이지를 통해 테스트해볼 수 있다.</p><p>크롬은 버전 49, 파이어폭스 52부터 지원한다. 파이어폭스 52가 2017년 3월에 릴리즈 된 것을 감안하면 이 속성 만으로 안심하긴 힘들 것 같다. 자세한 지원 여부는 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types">Link types</a>를 참고한다.</p><p>따라서 이러한 공격이 우려스러운 서비스(메일, 커뮤니티, 댓글 시스템 등)라면 <a href="https://danielstjules.github.io/blankshield/">blankshield</a>와 같은 라이브러리를 사용하자.</p><p>noopener 속성은 보안적 측면 외에도 성능 상의 이점도 취할 수 있다.</p><p>_blank 속성으로 열린 탭(페이지)는 언제든지 opener를 참조할 수 있다. 그래서 부모 탭과 같은 스레드에서 페이지가 동작한다. 이때 새탭의 페이지가 리소스를 많이 사용한다면 덩달아 부모 탭도 함께 느려진다.</p><p>noopener 속성을 사용해 열린 탭은 부모를 호출할 일이 없다. 따라서 같은 스레드 일 필요 없으며 새로운 페이지가 느리다고 부모 탭까지 느려질 일도 없다.</p>    <div class="alert alert--info">            <div class="alert__body">        <p>rel=&quot;noopener&quot; prevents window.opener, so there&#39;s no cross-window access. Chromium browsers optimise for this and open the new page in its own process.</p>      </div>    </div>  <p>자세한 내용은 <a href="https://jakearchibald.com/2016/performance-benefits-of-rel-noopener/">The performance benefits of rel=noopener</a>을 참고하자.</p><h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><ul><li><a href="http://www.azarask.in/blog/post/a-new-type-of-phishing-attack/">Tabnabbing: A New Type of Phishing Attack</a></li><li><a href="https://www.jitbit.com/alexblog/256-targetblank---the-most-underestimated-vulnerability-ever/">Target=”_blank” - the most underestimated vulnerability ever</a></li><li><a href="https://blog.jxck.io/entries/2016-06-12/noopener.html">링크에 rel=noopener를 부여해 Tabnabbing을 대비</a>(일본어)</li><li><a href="https://jakearchibald.com/2016/performance-benefits-of-rel-noopener/">The performance benefits of rel=noopener</a></li></ul>]]></content>
    
    
    <summary type="html">이 문서는 Tabnabbing 공격과 이를 막을 수 있는 rel=noopener 속성에 대해 소개합니다.</summary>
    
    
    
    <category term="JavaScript" scheme="http://blog.coderifleman.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://blog.coderifleman.com/tags/JavaScript/"/>
    
    <category term="Security" scheme="http://blog.coderifleman.com/tags/Security/"/>
    
    <category term="Attack" scheme="http://blog.coderifleman.com/tags/Attack/"/>
    
    <category term="Hacking" scheme="http://blog.coderifleman.com/tags/Hacking/"/>
    
  </entry>
  
  <entry>
    <title>프런트엔드 엔지니어를 위한 베지에 곡선(Bezier Curves) - 3편</title>
    <link href="http://blog.coderifleman.com/2017/03/19/bezier-curves-for-frontend-engineer-3/"/>
    <id>http://blog.coderifleman.com/2017/03/19/bezier-curves-for-frontend-engineer-3/</id>
    <published>2017-03-18T15:00:00.000Z</published>
    <updated>2022-11-09T05:45:21.010Z</updated>
    
    <content type="html"><![CDATA[<p>「<a href="/2017/01/03/bezier-curves-for-frontend-engineer-2/">프런트엔드 엔지니어를 위한 베지에 곡선(Bézier Curves) - 2편</a>」을 포스팅한 후 시간이 꽤 지났다. 어디까지 이야기했더라? 기억도 가물가물하다. 최근에 강의를 시작하면서 여유가 없었다는 핑계를 대보지만, 뭐가 됐든 게을러서 그렇다. 3편을 기다리신 분이 있었다면 죄송할 따름이다.</p><p>글과 관련 없는 얘기는 이쯤 하자. 2편에서는 <a href="/2017/01/03/bezier-curves-for-frontend-engineer-2/#%EC%97%90%EB%B2%84%EB%A6%AC%EC%A7%95%EA%B3%BC-%EB%B8%94%EB%A0%8C%EB%94%A9">에버리징과 블렌딩</a> 그리고 인터폴레이션(Interpolation)이라고 부르는 <a href="/2017/01/03/bezier-curves-for-frontend-engineer-2/#%EB%B3%B4%EA%B0%84">보간</a>을 소개했다. 베지에 곡선을 이해하기 위한 기초 지식이었으며 이 개념만 이해하고 있으면 나머지는 쉽게 이해할 수 있다.</p><h2 id="1차-베지에-곡선"><a href="#1차-베지에-곡선" class="headerlink" title="1차 베지에 곡선"></a>1차 베지에 곡선</h2><p>우리는 이미 1차 베지에 곡선(Linear Bezier Cuvers)을 경험했다. 2편의 <a href="/2017/01/03/bezier-curves-for-frontend-engineer-2/#%EB%B3%B5%ED%95%A9-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B8%94%EB%A0%8C%EB%94%A9">복합 데이터 블렌딩</a>과 <a href="/2017/01/03/bezier-curves-for-frontend-engineer-2/#%EB%B3%B4%EA%B0%84">보간</a> 절에서 보여준 예제가 바로 1차 베지에 곡선이다. 차이점이 있다면 단순히 평면상에서 곡선을 그리는 게 아니라 <a href="https://ko.wikipedia.org/wiki/%EC%A7%81%EA%B5%90_%EC%A2%8C%ED%91%9C%EA%B3%84">직교좌표계</a> 상에서 그린다는 것이다.</p>    <figure title="1차 베지에 곡선">      <a href="/images/bezier-curves-for-frontend-engineer-3/bezier-for-frontend.01.png" target="_blank">        <img           src="/images/bezier-curves-for-frontend-engineer-3/bezier-for-frontend.01.png"           alt="1차 베지에 곡선"           style="max-width:340px"        >      </a>      <figcaption>&lt;그림 1. 1차 베지에 곡선&gt;</figcaption>    </figure>  <p>1차 베지에 곡선은 조절점(Control point) 두 개로 그린다. 아주 간단하지만, 굴곡이 없는 <a href="https://ko.wikipedia.org/wiki/%EC%84%A0%ED%98%95%EC%84%B1">선형</a>이다(직선도 곡선에 포함된다는 사실을 잊지 말자). </p><h2 id="2차-베지에-곡선"><a href="#2차-베지에-곡선" class="headerlink" title="2차 베지에 곡선"></a>2차 베지에 곡선</h2><p>그럼 2차 베지에 곡선(Quadratic Bézier Curves)을 그려보자. 2차 베지에 곡선은 조절점 3개를 이용해 그린 곡선을 말한다.</p>    <figure title="2차 베지에 곡선">      <a href="/images/bezier-curves-for-frontend-engineer-3/bezier-for-frontend.02.png" target="_blank">        <img           src="/images/bezier-curves-for-frontend-engineer-3/bezier-for-frontend.02.png"           alt="2차 베지에 곡선"           style="max-width:340px"        >      </a>      <figcaption>&lt;그림 2. 2차 베지에 곡선&gt;</figcaption>    </figure>  <p>3개의 조절점 A, B, C를 이용해 그린 두 개의 직선 즉, 두 개의 1차 베지에 곡선이 있다. 그리고 이 곡선에서 보간되는 점 E와 F도 있다. 이때 점 E와 F를 이용해 또 다른 직선을 그릴 수 있고 이 직선에서 보간되는 점 P도 추가할 수 있다. 이제 점 E와 F 그리고 P를 보간하면 P의 행적이 곡선을 만들어 낸다(이해가 되지 않는다면 「<a href="/2016/12/30/bezier-curves/">중학생도 알 수 있는 베지에 곡선</a>」을 참고한다).</p><p>그럼 이제 2차 베지에 곡선을 직접 그려보도록 하자. 선분에서 블렌딩 되는 점 P를 구하는 공식은 다음과 같다(자세한 내용은 「<a href="/2017/01/03/bezier-curves-for-frontend-engineer-2/">프런트엔드 엔지니어를 위한 베지에 곡선(Bézier Curves) - 2편</a>」을 참고). 이때 <code>s = 1 - t</code>다.</p><pre class="language-text" data-language="text"><code class="language-text">P &#x3D; (s * A) + (t * B)</code></pre><p>그림 2를 보면 알 수 있듯이 2차 베지에 곡선을 그리기 위해서는 점 E와 F 그리고 P를 보간해야 한다. 점 E는 조절점 A와 B를 이용해 구할 수 있고, 점 F는 조절점 B와 C를 이용해 구할 수 있다. 그리고 점 P는 다시 점 E와 F를 이용해 구할 수 있다.</p><pre class="language-text" data-language="text"><code class="language-text">E &#x3D; (s * A) + (t * B)F &#x3D; (s * B) + (t * C)P &#x3D; (s * E) + (t * F)</code></pre><p>이 공식을 자바스크립트 코드로 옮겨보자. 여기에서는 구현에 있어 몇 가지 중요한 함수만 소개한다. 전체 코드는 코드펜(CodePen)에 작성해 놓은 <a href="http://codepen.io/uyeong/pen/qrpYwj">예제</a>를 참고한다.</p><p>먼저 blender()는 점 A와 점 B 그리고 가중치 t를 전달받아 블랜딩한 결괏값을 반환하는 함수다.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">blender</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">,</span> t</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token constant">A</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token constant">B</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> t<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token constant">A</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>t <span class="token operator">*</span> <span class="token constant">B</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// or A + t * (B - A)</span><span class="token punctuation">&#125;</span></code></pre><p>이때 blender()는 좌표 하나에 대한 연산만 책임지므로 x, y 좌표를 연산하기 위해 blend()를 작성한다.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">blend</span><span class="token punctuation">(</span><span class="token parameter">x1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> y2<span class="token punctuation">,</span> t</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token function">blender</span><span class="token punctuation">(</span>x1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> y <span class="token operator">=</span> <span class="token function">blender</span><span class="token punctuation">(</span>y1<span class="token punctuation">,</span> y2<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>x<span class="token punctuation">,</span> y<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>다음으로 blend()를 이용해 점 A와 점 B의 좌표를 전달해 점 E의 좌푯값을 구하고 점 B와 점 C의 좌표를 전달해 점 F의 좌표를 구한다. 그리고 다시 점 E와 점 F의 좌표를 전달해 점 P의 좌표를 구하는 방식으로 공식을 구현한다.</p><pre class="language-js" data-language="js"><code class="language-js">interpolateBtn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>\'click\'<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// Start the interpolation.</span>  <span class="token function">raf</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">t</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> posE <span class="token operator">=</span> <span class="token function">blend</span><span class="token punctuation">(</span>posA<span class="token punctuation">.</span>x<span class="token punctuation">,</span> posB<span class="token punctuation">.</span>x<span class="token punctuation">,</span> posA<span class="token punctuation">.</span>y<span class="token punctuation">,</span> posB<span class="token punctuation">.</span>y<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> posF <span class="token operator">=</span> <span class="token function">blend</span><span class="token punctuation">(</span>posB<span class="token punctuation">.</span>x<span class="token punctuation">,</span> posC<span class="token punctuation">.</span>x<span class="token punctuation">,</span> posB<span class="token punctuation">.</span>y<span class="token punctuation">,</span> posC<span class="token punctuation">.</span>y<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> posP <span class="token operator">=</span> <span class="token function">blend</span><span class="token punctuation">(</span>posE<span class="token punctuation">.</span>x<span class="token punctuation">,</span> posF<span class="token punctuation">.</span>x<span class="token punctuation">,</span> posE<span class="token punctuation">.</span>y<span class="token punctuation">,</span> posF<span class="token punctuation">.</span>y<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">...</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>아래 데모를 실행해 보자. 점 P가 보간되면서 그려진 곡선을 2차 베지에 곡선이라고 한다.</p>    <p data-height="300" data-theme-id="0" data-slug-hash="qrpYwj" data-default-tab="result" data-user="uyeong" data-embed-version="2" data-pen-title="qrpYwj" class="codepen">      See the Pen <a href="http://codepen.io/uyeong/pen/qrpYwj/">qrpYwj</a> by Uyeong Ju (<a href="http://codepen.io/uyeong">@uyeong</a>) on <a href="http://codepen.io">CodePen</a>.    </p>  <h3 id="수식-정리"><a href="#수식-정리" class="headerlink" title="수식 정리"></a>수식 정리</h3><p>우리가 2차 베지에 곡선을 위해 사용한 수식은 다음과 같다.</p><pre class="language-text" data-language="text"><code class="language-text">E &#x3D; (s * A) + (t * B)F &#x3D; (s * B) + (t * C)P &#x3D; (s * E) + (t * F)</code></pre><p>하지만 이 수식은 조금 장황하며 자바스크립트 코드상에서도 함수 호출이 빈번한 상태다. 이 수식을 방정식으로  좀더 간결하고 효율적으로 표현할 수 있다. 일단 연산식에 있는 괄호를 없애고 좀더 간략하게 수식을 표현한다.</p><pre class="language-text" data-language="text"><code class="language-text">E(t) &#x3D; sA + tBF(t) &#x3D; sB + tCP(t) &#x3D; sE(t) + tF(t)</code></pre><p>이번엔 중학생 때 배워본 몇 가지 <a href="https://ko.wikipedia.org/wiki/%EA%B3%B1%EC%85%88_%EA%B3%B5%EC%8B%9D">곱셈 공식</a> 사용하여 세 줄로 표현한 수식을 한 줄로 작성하고 이차방정식으로 정리한다.</p><pre class="language-text" data-language="text"><code class="language-text">P(t) &#x3D; s(sA + tB) + t(sB + tC)P(t) &#x3D; (s²)A + (st)B + (st)B + (t²)CP(t) &#x3D; (s²)A + 2(st)B + (t²)C</code></pre><p>자, 몇 가지 규칙을 더 추가하자. t가 0이라면 P는 항상 A와 같으며 다음과 같이 증명할 수 있다.</p><pre class="language-text" data-language="text"><code class="language-text">P(t) &#x3D; (s²)A + 2(st)B + (t²)CP(t) &#x3D; (1²)A + 2(1 * 0)B + (0²)CP(t) &#x3D; (1)A + 2(0)B + (0)CP(t) &#x3D; (1)AP(t) &#x3D; A</code></pre><p>다시 t가 1이라면 P는 항상 C와 같으며 다음과 같이 증명할 수 있다.</p><pre class="language-text" data-language="text"><code class="language-text">P(t) &#x3D; (s²)A + 2(st)B + (t²)CP(t) &#x3D; (0²)A + 2(0 * 1)B + (1²)CP(t) &#x3D; (0)A + 2(0)B + (1)CP(t) &#x3D; (1)CP(t) &#x3D; C</code></pre><p>이제 정리한 수식을 자바스크립트로 작성해보자. 함수명은 <code>quadBezier</code>로 짓고 2차 베지에 곡선임을 나타낸다.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">quadBezier</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">C</span><span class="token punctuation">,</span> t</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token constant">A</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token constant">C</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">const</span> s <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> t<span class="token punctuation">;</span>    <span class="token comment">// (s²)A + 2(st)B + (t²)C</span>  <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token constant">A</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token punctuation">(</span>s <span class="token operator">*</span> t<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token constant">B</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token constant">C</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>이렇게 작성한 함수는 다음과 같이 사용할 수 있다.</p><pre class="language-js" data-language="js"><code class="language-js">interpolateBtn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>\'click\'<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// Start the interpolation.</span>  <span class="token function">raf</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">t</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token function">quadBezier</span><span class="token punctuation">(</span>posA<span class="token punctuation">.</span>x<span class="token punctuation">,</span> posB<span class="token punctuation">.</span>x<span class="token punctuation">,</span> posC<span class="token punctuation">.</span>x<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> y <span class="token operator">=</span> <span class="token function">quadBezier</span><span class="token punctuation">(</span>posA<span class="token punctuation">.</span>y<span class="token punctuation">,</span> posB<span class="token punctuation">.</span>y<span class="token punctuation">,</span> posC<span class="token punctuation">.</span>y<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">...</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="3차-베지에-곡선"><a href="#3차-베지에-곡선" class="headerlink" title="3차 베지에 곡선"></a>3차 베지에 곡선</h2><p>이제 3차 베지에 곡선(Cubic Bézier Curves)을 그려보자. 2차 베지에 곡선은 3개의 조절점을 이용해 그린 곡선을 말하듯 3차 베지에 곡선은 4개의 조절점을 이용해 그린 곡선을 말한다. 더 정확히는 두 개의 2차 베지에 곡선을 이용해 그린 곡선을 말한다.</p>    <figure title="3차 베지에 곡선">      <a href="/images/bezier-curves-for-frontend-engineer-3/bezier-for-frontend.03.png" target="_blank">        <img           src="/images/bezier-curves-for-frontend-engineer-3/bezier-for-frontend.03.png"           alt="3차 베지에 곡선"           style="max-width:340px"        >      </a>      <figcaption>&lt;그림 3. 3차 베지에 곡선&gt;</figcaption>    </figure>  <p>조절점 A, B, C를 이용해 그린 2차 베지에 곡선과 조절점 B, C, D를 이용해 그린 2차 베지에 곡선이 있다. 그리고 각 2차 베지에 곡선에서 보간되는 점 Q와 R이 있다. 이때 점 Q와 R를 이용해 또 다른 직선을 그릴 수 있고 이 직선에서 보간되는 점 P도 추가할 수 있다. 이제 점 Q와 R 그리고 P를 보간하면 P의 행적이 곡선을 만들어 낸다.</p><p>이제 3차 베지에 곡선을 직접 그려보자. 3차 베지에 곡선을 그리기 위해서는 보간되는 점 Q와 R 그리고 P를 구해야 한다. 점 Q는 다음과 같이 구할 수 있다.</p><pre class="language-text" data-language="text"><code class="language-text">E &#x3D; (s * A) + (t * B)F &#x3D; (s * B) + (t * C)Q &#x3D; (s * E) + (t * F)</code></pre><p>다시 점 R은 다음과 같이 구할 수 있다.</p><pre class="language-text" data-language="text"><code class="language-text">F &#x3D; (s * B) + (t * C)G &#x3D; (s * C) + (t * D)R &#x3D; (s * F) + (t * G)</code></pre><p>이제 점 Q와 R을 이용해 점 P를 구할 수 있다.</p><pre class="language-text" data-language="text"><code class="language-text">P &#x3D; (s * Q) + (t * R)</code></pre><p>이제 2차 베지에 곡선을 그릴 때 작성한 blend, blender 함수를 활용해 3차 베지에 곡선을 그려보자. 간단하게 새로운 점을 추가한 후 위에서 설명한 것처럼 점 Q, R, P를 구해 보간하면 된다.</p><p>아래 데모를 실행해 보자. 점 P가 보간되면서 그려진 곡선을 3차 베지에 곡선이라고 한다.</p>    <p data-height="300" data-theme-id="0" data-slug-hash="EmOPJr" data-default-tab="result" data-user="uyeong" data-embed-version="2" data-pen-title="EmOPJr" class="codepen">      See the Pen <a href="http://codepen.io/uyeong/pen/EmOPJr/">EmOPJr</a> by Uyeong Ju (<a href="http://codepen.io/uyeong">@uyeong</a>) on <a href="http://codepen.io">CodePen</a>.    </p>  <h3 id="수식정리"><a href="#수식정리" class="headerlink" title="수식정리"></a>수식정리</h3><p>점 Q와 P는 각각 2차 베지에 곡선에서 구해지는 점이므로 2차 베지에 곡선의 수식으로 표현할 수 있다.</p><pre class="language-text" data-language="text"><code class="language-text">Q(t) &#x3D; (s²)A + 2(st)B + (t²)CR(t) &#x3D; (s²)B + 2(st)C + (t²)DP(t) &#x3D; sQ(t) + tR(t)</code></pre><p>위 수식을 조금 더 풀어서 다음과 같이 정리할 수 있다.</p><pre class="language-text" data-language="text"><code class="language-text">P(t) &#x3D; s((s²)A + 2(st)B + (t²)C) + t((s²)B + 2(st)C + (t²)D)P(t) &#x3D; s³A + 2(s²t)B + st²C + s²tB + 2(st²)C + t³DP(t) &#x3D; s³A + 3(s²t)B + 3(st²)C + t³D</code></pre><p>이제 정리한 수식을 자바스크립트로 작성해보자. 함수명은 <code>cubicBezier</code>로 짓고 3차 베지에 곡선임을 나타낸다.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">cubicBezier</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">C</span><span class="token punctuation">,</span> <span class="token constant">D</span><span class="token punctuation">,</span> t</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token constant">A</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span> t <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token constant">D</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">const</span> s <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> t<span class="token punctuation">;</span>    <span class="token comment">// P = s³A + 3(s²t)B + 3(st²)C + t³D  </span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token constant">A</span> <span class="token operator">+</span>     <span class="token number">3</span> <span class="token operator">*</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">*</span> t<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token constant">B</span> <span class="token operator">+</span>     <span class="token number">3</span> <span class="token operator">*</span> <span class="token punctuation">(</span>s <span class="token operator">*</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token constant">C</span> <span class="token operator">+</span>     Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token constant">D</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>이렇게 작성한 함수는 다음과 같이 사용할 수 있다.</p><pre class="language-js" data-language="js"><code class="language-js">interpolateBtn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>\'click\'<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// Start the interpolation.</span>  <span class="token function">raf</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">t</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token function">cubicBezier</span><span class="token punctuation">(</span>posA<span class="token punctuation">.</span>x<span class="token punctuation">,</span> posB<span class="token punctuation">.</span>x<span class="token punctuation">,</span> posC<span class="token punctuation">.</span>x<span class="token punctuation">,</span> posD<span class="token punctuation">.</span>x<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> y <span class="token operator">=</span> <span class="token function">cubicBezier</span><span class="token punctuation">(</span>posA<span class="token punctuation">.</span>y<span class="token punctuation">,</span> posB<span class="token punctuation">.</span>y<span class="token punctuation">,</span> posC<span class="token punctuation">.</span>y<span class="token punctuation">,</span> posD<span class="token punctuation">.</span>y<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">...</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="애니메이션"><a href="#애니메이션" class="headerlink" title="애니메이션"></a>애니메이션</h3><p>실제 동작하는 데모에서 <code>requestAnimationFrame()</code>을 사용해 일정한 시간마다 점을 찍는 것으로 3차 베지에 곡선을 그리고 있다. 그런데 곡선의 각 점이 찍히는 구간 즉, 보폭이 일정하지 않다.</p>    <figure title="3차 베지에 곡선의 보폭">      <a href="/images/bezier-curves-for-frontend-engineer-3/bezier-for-frontend.04.png" target="_blank">        <img           src="/images/bezier-curves-for-frontend-engineer-3/bezier-for-frontend.04.png"           alt="3차 베지에 곡선의 보폭"           style="max-width:340px"        >      </a>      <figcaption>&lt;그림 4. 3차 베지에 곡선의 보폭&gt;</figcaption>    </figure>  <p>이러한 특징을 애니메이션 처리에 활용할 수 있다. 보폭이 크면 시간이 빠르게 흐르고 보폭이 작으면 시간이 천천히 흐르도록 표현하여 객체의 움직임에 역동성을 부여할 수 있다.</p>    <figure title="Easing Functions 치트시트">      <a href="/images/bezier-curves-for-frontend-engineer-3/bezier-for-frontend.05.png" target="_blank">        <img           src="/images/bezier-curves-for-frontend-engineer-3/bezier-for-frontend.05.png"           alt="Easing Functions 치트시트"           style="max-width:340px"        >      </a>      <figcaption>&lt;그림 5. Easing Functions 치트시트&gt;</figcaption>    </figure>  <p>이제 CSS의 <code>transition-timing-function</code>의 <code>cubic-bezier(Bx, By, Cx, Cy)</code>가 의미하는 바가 무엇인지 또 어떻게 객체의 움직임에 활력을 불어넣을 수 있게 되는지도 이해할 수 있을 것이다.</p><h2 id="끝으로"><a href="#끝으로" class="headerlink" title="끝으로"></a>끝으로</h2><p>여기까지 베지에 곡선에 대한 연재 글을 모두 마친다. 처음엔 필자 역시 단순 호기심으로 시작했지만, 점점 원리를 알아가는 과정에서 상당한 재미를 느꼈다. 연재 글을 읽는 독자분들 역시 재미있는 경험이었길 바란다.</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="http://fei.edu.br/~psergio/CG_arquivos/IntroSplines.pdf">An Introduction to Bezier Curves, B-Splines, and Tensor<br>Product Surfaces with History and Applications</a></li><li><a href="http://www.essentialmath.com/GDC2012/GDC12_Eiserloh_Squirrel_Interpolation-and-Splines.ppt">GDC12 Eiserloh Squirrel Interpolation and Splines</a></li><li><a href="https://www.tsplines.com/resources/class_notes/Bezier_curves.pdf">BEZIER CURVES</a></li></ul>]]></content>
    
    
    <summary type="html">이 문서는 프런트개발에 있어서 유용하게 사용되는 베지에 곡선(Bezier Curves)의 원리를 수학적으로 자세히 소개하는 글의 세 번째 편입니다.</summary>
    
    
    
    <category term="Algorithm" scheme="http://blog.coderifleman.com/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="http://blog.coderifleman.com/tags/Algorithm/"/>
    
    <category term="BezierCurves" scheme="http://blog.coderifleman.com/tags/BezierCurves/"/>
    
    <category term="Spline" scheme="http://blog.coderifleman.com/tags/Spline/"/>
    
    <category term="Animation" scheme="http://blog.coderifleman.com/tags/Animation/"/>
    
    <category term="Math" scheme="http://blog.coderifleman.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>프런트엔드 엔지니어를 위한 베지에 곡선(Bezier Curves) - 2편</title>
    <link href="http://blog.coderifleman.com/2017/01/03/bezier-curves-for-frontend-engineer-2/"/>
    <id>http://blog.coderifleman.com/2017/01/03/bezier-curves-for-frontend-engineer-2/</id>
    <published>2017-01-02T15:00:00.000Z</published>
    <updated>2022-11-09T05:45:21.010Z</updated>
    
    <content type="html"><![CDATA[<p>베지에 곡선과 관련된 수학적 증명 방법과 알고리즘은 1959년 프랑스의 자동차 업체 <a href="http://www.citroen.com/en">시트로엥(citroen)</a>에서 근무하던 물리학자이자 수학자인 <a href="https://en.wikipedia.org/wiki/Paul_de_Casteljau">파울 드 카스텔조(Paul de Casteljau)</a>가 최초 고안했다. 다른 말로 카스텔조 곡선(Casteljau curve)이라고 부른다.</p><p>하지만 시트로엥의 정책으로 인해 카스텔조가 얻은 성과가 1974년까지 발표되지 못했고 1962년에 프랑스 자동차 회사 르노(<a href="https://group.renault.com/">Renault</a>)에서 근무하던 엔지니어 피에르 베지에(<a href="https://en.wikipedia.org/wiki/Pierre_B%C3%A9zier">Pierre Bézier</a>)가 자동차를 디자인하는 과정에서 이 곡선을 독자적으로 개발해 사용하면서 그의 이름으로 널리 알려지게 된다.</p><h2 id="정의"><a href="#정의" class="headerlink" title="정의"></a>정의</h2><p>베지에 곡선은 간단히 말해 복수의 조절점(<a href="https://en.wikipedia.org/wiki/Control_point_&#40;mathematics&#41;">Control point</a>)을 이용해 매끄러운 곡선을 그릴 수 있는 가장 일반적인 매개 변수 곡선(<a href="https://en.wikipedia.org/wiki/Parametric_equation">Parametric curve</a>) 이다. 매개 변수 곡선이란 매개 변수를 사용해 함수를 일반화하여 곡선을 그려내는 방법을 말한다.</p>    <figure title="베지에 곡선의 조절점과 가이드 포인트">      <a href="/images/bezier-curves-for-frontend-engineer-2/bezier-for-frontend.01.png" target="_blank">        <img           src="/images/bezier-curves-for-frontend-engineer-2/bezier-for-frontend.01.png"           alt="베지에 곡선의 조절점과 가이드 포인트"           style="max-width:340px"        >      </a>      <figcaption>&lt;그림 1. 베지에 곡선의 조절점과 가이드 포인트&gt;</figcaption>    </figure>  <p>조절점이란 곡선의 모양을 결정하는 데 사용되는 점의 집합 또는 구성원을 뜻하며 가이드 포인트는 곡선의 모양을 변경시킬 수 있는 조절 가능한 점을 뜻한다. 그림 1의 점을 왼쪽부터 차례대로 P0, P1, P2, P3라고 할 때 보통 P0와 P3는 고정해두고 P1과 P2를 조절해 곡선을 변형한다. 이때 이 P1과 P2를 가이드 포인트라 한다.</p><p>베지에 곡선엔 차수가 붙는데 이 차수는 조절점의 개수에 따라 정해진다. 간단히 말해 N 개의 조절점으로 그려진 곡선을 N - 1차 베지에 곡선이라 한다. 예를 들어 그림 1은 조절점이 4개이므로 4 - 1 즉, 3차 베지에 곡선이다.</p><p>베지에 곡선이 그려지는 개괄적인 원리는 이전에 포스팅했던 「<a href="http://blog.coderifleman.com/2016/12/30/bezier-curves/">중학생도 알 수 있는 베지에 곡선(Bézier Curves)</a>」을 참고하자. GIF 애니메이션을 이용해 이해하기 쉽게 설명돼 있다.</p><p>이번 편에서는 블렌딩(Blending)과 보간(Interpolcation)을 소개한다. 이 지식만 습득하면 나머지 n 차 베지에 곡선은 자연스럽게 이해할 수 있다.</p><h2 id="에버리징과-블렌딩"><a href="#에버리징과-블렌딩" class="headerlink" title="에버리징과 블렌딩"></a>에버리징과 블렌딩</h2>    <figure title="점 A와 점 B의 중앙">      <a href="/images/bezier-curves-for-frontend-engineer-2/bezier-for-frontend.02.png" target="_blank">        <img           src="/images/bezier-curves-for-frontend-engineer-2/bezier-for-frontend.02.png"           alt="점 A와 점 B의 중앙"           style=""        >      </a>      <figcaption>&lt;그림 2. 점 A와 점 B의 중앙&gt;</figcaption>    </figure>  <p>자, 위 그림 2와 같이 서로 떨어져 있는 점 A와 점 B가 있다고 해보자. 이때 점 P를 이 두 점 사이의 평균 즉,  <a href="http://dic.daum.net/word/view.do?wordid=kkw000140374&supid=kku000175471">선분</a>의 중앙에 두고 싶다면 어떻게 해야 할까?</p><pre class="language-text" data-language="text"><code class="language-text">P &#x3D; (A + B) &#x2F; 2</code></pre><p>위처럼 간단히 평균을 구해 중앙에 둘 수 있다. 이 수식을 조금 다르게 전개해보자.</p><pre class="language-text" data-language="text"><code class="language-text">P &#x3D; (A + B) &#x2F; 2  &#x3D; (A + B) * ½  &#x3D; ½A + ½B  &#x3D; .5A + .5B  &#x3D; (.5 * A) + (.5 * B)</code></pre><p>위 수식을 이용한 연산을 블렌딩(Blending)이라고 표현한다. 지정된 각각의 비율에 맞춰 적절히 혼합하는 것이다. 자, 이제 같은 값이 아닌 가중치(Weights)를 줘서 블렌딩해보자.</p>    <figure title="점 A와 점 B의 블렌딩 비율 조절">      <a href="/images/bezier-curves-for-frontend-engineer-2/bezier-for-frontend.03.png" target="_blank">        <img           src="/images/bezier-curves-for-frontend-engineer-2/bezier-for-frontend.03.png"           alt="점 A와 점 B의 블렌딩 비율 조절"           style=""        >      </a>      <figcaption>&lt;그림 3. 점 A와 점 B의 블렌딩 비율 조절&gt;</figcaption>    </figure>  <pre class="language-text" data-language="text"><code class="language-text">P &#x3D; (.35 * A) + (.65 * B)&#39; </code></pre><p>이번엔 A는 0.35(35%), B는 0.65(65%)로 비율을 조정해 블렌딩했다. 이때 두 비율의 합은 당연하겠지만 1(100%)이 돼야 한다. 이것은 반드시 지켜져야 할 필수 조건이다. 이어서 비율 값을 다음과 같이 일반화해보자.</p><pre class="language-text" data-language="text"><code class="language-text">P &#x3D; (s * A) + (t * B)&#39; </code></pre><p>s는 A의 비율을, t는 B의 비율을 나타낸다. 만약 s가 높으면 t는 낮아지고 반대로 t가 높으면 s는 낮아질 것이다. 잠깐, s와 t는 서로 영향을 주며 두 수의 합은 항상 1이 돼야 한다. 그렇다면 s는 <code>1 - t</code>와 같다고 할 수 있다.</p><pre class="language-text" data-language="text"><code class="language-text">P &#x3D; ((1-t) * A) + (t * B)&#39; </code></pre><p>이제 변수 t 하나만으로 비율을 조정해 블렌딩할 수 있다. 이 수식은 다음과 같이 표현될 수 있다.</p><pre class="language-text" data-language="text"><code class="language-text">P &#x3D; ((1 - t) * A) + (t * B)  &#x3D; (1 - t) * A + t * B  &#x3D; A - tA + tB  &#x3D; A + t(-A + B)  &#x3D; A + t(B - A)</code></pre><p>이 글에서는 수식 <code>P = (s * A) + (t * B)</code>를 사용해 설명을 이어가겠다. 다시 한번 말하지만 <code>s = 1 - t</code>다. 여기에 몇 가지 규칙이 추가된다. 만약 변수 t가 0이라면 P는 항상 A와 같으므로 다음과 같이 표현될 수 있다.</p><pre class="language-text" data-language="text"><code class="language-text">P &#x3D; ((1 - t) * A) + (t * B)  &#x3D; ((1 - 0) * A) + (0 * B)  &#x3D; (1 * A) + (0 * B)  &#x3D; A</code></pre><p>또 변수 t가 1이라면 P는 항상 B와 같으므로 다음과 같이 표현될 수 있다.</p><pre class="language-text" data-language="text"><code class="language-text">P &#x3D; ((1 - t) * A) + (t * B)  &#x3D; ((1 - 1) * A) + (1 * B)  &#x3D; (0 * A) + (1 * B)  &#x3D; A + B - A  &#x3D; B</code></pre><p>이제 수식과 몇 가지 규칙을 참고하여 블렌딩하는 자바스크립트 함수를 작성해보자.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> <span class="token constant">A</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token constant">B</span> <span class="token operator">=</span> <span class="token number">198</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">blender</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">,</span> t</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token constant">A</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token constant">B</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> t<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token constant">A</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>t <span class="token operator">*</span> <span class="token constant">B</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// or A + t * (B - A)</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> blend <span class="token operator">=</span> <span class="token function">blender</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">blend</span><span class="token punctuation">(</span><span class="token number">.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">blend</span><span class="token punctuation">(</span><span class="token number">.2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 55.6</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">blend</span><span class="token punctuation">(</span><span class="token number">.4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 91.2</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">blend</span><span class="token punctuation">(</span><span class="token number">.6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 126.8</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">blend</span><span class="token punctuation">(</span><span class="token number">.8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 162.4</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">blend</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 198</span></code></pre>    <p data-height="300" data-theme-id="0" data-slug-hash="qRBdvb" data-default-tab="result" data-user="uyeong" data-embed-version="2" data-pen-title="qRBdvb" class="codepen">      See the Pen <a href="http://codepen.io/uyeong/pen/qRBdvb/">qRBdvb</a> by Uyeong Ju (<a href="http://codepen.io/uyeong">@uyeong</a>) on <a href="http://codepen.io">CodePen</a>.    </p>  <h2 id="복합-데이터-블렌딩"><a href="#복합-데이터-블렌딩" class="headerlink" title="복합 데이터 블렌딩"></a>복합 데이터 블렌딩</h2><p>이번에는 「에버리징과 블렌딩」 절에서 이해한 수식을 이용해 복합 데이터(Compound data)를 블렌딩해보자. 블렌딩 수식만 잘 활용하면 2차원 또는 3차원 같은 복합적인 데이터도 쉽게 블렌딩할 수 있다.</p><pre class="language-text" data-language="text"><code class="language-text">Px &#x3D; (s * Ax) + (t * Bx)Py &#x3D; (s * Ay) + (t * By)Pz &#x3D; (s * Az) + (t * Bz)</code></pre><p>3차원인 경우 위처럼 개별적으로 블렌딩한 후 연산된 값을 조합해 사용한다.</p>    <figure title="2차원에서 점 A와 점 B의 중앙">      <a href="/images/bezier-curves-for-frontend-engineer-2/bezier-for-frontend.04.png" target="_blank">        <img           src="/images/bezier-curves-for-frontend-engineer-2/bezier-for-frontend.04.png"           alt="2차원에서 점 A와 점 B의 중앙"           style=""        >      </a>      <figcaption>&lt;그림 4. 2차원에서 점 A와 점 B의 중앙&gt;</figcaption>    </figure>  <p>전 절에서는 점 A와 점 B가 동일 선상에 놓여있는 1차원적 상황이었지만 이번엔 그림 4 처럼 2차원 상황에서 P를 구해보자. 2차원에서는 x와 y 좌표로 점의 위치가 결정된다. 따라서 x와 y를 개별적으로 블렌딩한 후 구해진 값을 조합하면 P의 위치를 구할 수 있다.</p>    <figure title="2차원에서 점 P의 위치 구하기">      <a href="/images/bezier-curves-for-frontend-engineer-2/bezier-for-frontend.05.png" target="_blank">        <img           src="/images/bezier-curves-for-frontend-engineer-2/bezier-for-frontend.05.png"           alt="2차원에서 점 P의 위치 구하기"           style=""        >      </a>      <figcaption>&lt;그림 5. 2차원에서 점 P의 위치 구하기&gt;</figcaption>    </figure>  <pre class="language-text" data-language="text"><code class="language-text">Px &#x3D; (s * Ax) + (t * Bx)Py &#x3D; (s * Ay) + (t * By)P &#x3D; &#123;Px, Py&#125;</code></pre><p>위 수식은 자바스크립트 코드로 다음과 같이 표현할 수 있다.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> Ax <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">const</span> Ay <span class="token operator">=</span> <span class="token number">144</span><span class="token punctuation">;</span><span class="token keyword">const</span> Bx <span class="token operator">=</span> <span class="token number">198</span><span class="token punctuation">;</span><span class="token keyword">const</span> By <span class="token operator">=</span> <span class="token number">72</span><span class="token punctuation">;</span><span class="token keyword">const</span> blendX <span class="token operator">=</span> <span class="token function">blender</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> Ax<span class="token punctuation">,</span> Bx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> blendY <span class="token operator">=</span> <span class="token function">blender</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> Ay<span class="token punctuation">,</span> By<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// t = .5</span><span class="token comment">// P = &#123; blendX(t), blendY(t) &#125;</span></code></pre>    <p data-height="300" data-theme-id="0" data-slug-hash="EZxVVV" data-default-tab="result" data-user="uyeong" data-embed-version="2" data-pen-title="EZxVVV" class="codepen">      See the Pen <a href="http://codepen.io/uyeong/pen/EZxVVV/">EZxVVV</a> by Uyeong Ju (<a href="http://codepen.io/uyeong">@uyeong</a>) on <a href="http://codepen.io">CodePen</a>.    </p>  <h2 id="보간"><a href="#보간" class="headerlink" title="보간"></a>보간</h2><p>마지막으로 보간(Interpolation)의 개념을 짤막하게 소개한다. 러핑(Lerping)이라고도 부르는 보간은 <strong>시간이 지남에 따라 블랜드 가중치를 변경하여 블렌딩을 수행하는 것</strong>을 말한다. 시간은 멈춰있지 않고 지속해서 흐르는 특징이 있으며 블랜드 가중치는 이 흐르는 시간에 의해 결정된다.</p><p>쉽게 말해 특정 값으로 블렌딩하는 게 아닌 지속해서 흐르는 시간에 근거해 블렌딩 하는 것이다. 이러한 과정은 대개 update()로 표현된다. 아래 자바스크립트 코드를 보자.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">interpolator</span><span class="token punctuation">(</span><span class="token parameter">Ax<span class="token punctuation">,</span> Bx<span class="token punctuation">,</span> Ay<span class="token punctuation">,</span> By<span class="token punctuation">,</span> duration</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">update</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">// x, y 블랜드 함수 준비</span>    <span class="token keyword">const</span> blendX <span class="token operator">=</span> <span class="token function">blender</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> Ax<span class="token punctuation">,</span> Bx<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> blendY <span class="token operator">=</span> <span class="token function">blender</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> Ay<span class="token punctuation">,</span> By<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">...</span> 중략 <span class="token operator">...</span>        <span class="token keyword">function</span> <span class="token function">step</span><span class="token punctuation">(</span><span class="token parameter">timestamp</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token operator">...</span> 중략 <span class="token operator">...</span>            <span class="token comment">// 현재 시간에 해당하는 진행 값 즉, t 값 연산</span>      <span class="token keyword">const</span> pastTime <span class="token operator">=</span> timestamp <span class="token operator">-</span> startTime<span class="token punctuation">;</span>      <span class="token keyword">let</span> progress <span class="token operator">=</span> pastTime <span class="token operator">/</span> duration<span class="token punctuation">;</span>   <span class="token comment">// t 값을 이용해 블렌딩하고 update 콜백 함수 호출</span>      <span class="token function">update</span><span class="token punctuation">(</span><span class="token function">blendX</span><span class="token punctuation">(</span>progress<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">blendY</span><span class="token punctuation">(</span>progress<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Blending...</span>      <span class="token operator">...</span> 중략 <span class="token operator">...</span>            <span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span>step<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span>step<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> interpolate <span class="token operator">=</span> <span class="token function">interpolator</span><span class="token punctuation">(</span>Ax<span class="token punctuation">,</span> Bx<span class="token punctuation">,</span> Ay<span class="token punctuation">,</span> By<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">interpolate</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nx<span class="token punctuation">,</span> ny</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 1초간 Interpolating.</span><span class="token comment">// P = &#123;nx, ny&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>우선 requestAnimationFrame()를 사용해 지정한 시간 만큼 흐르게 한다. 그리고 현재 시각에 해당하는 진행 값 즉, t를 구한 후 이 값을 근거해 블렌딩한다.</p>    <p data-height="300" data-theme-id="0" data-slug-hash="dNbgQp" data-default-tab="result" data-user="uyeong" data-embed-version="2" data-pen-title="dNbgQp" class="codepen">      See the Pen <a href="http://codepen.io/uyeong/pen/dNbgQp/">dNbgQp</a> by Uyeong Ju (<a href="http://codepen.io/uyeong">@uyeong</a>) on <a href="http://codepen.io">CodePen</a>.    </p>  <p>보간은 페이드인, 아웃 같은 애니메이션 처리나 3D 게임에서의 객체 움직임 그리고 오디오 크로스페이드 처리 등에 유용하게 사용된다.</p><p>여기까지 2편을 마치고, 다음 편에서 이 지식을 바탕으로 1, 2차 베지에 곡선을 소개하겠다.</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://www.desmos.com/calculator/cahqdxeshd">Interpolation and Splines</a></li><li><a href="https://www.w3.org/TR/2001/REC-smil-animation-20010904/">SMIL Animation</a></li><li><a href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve">Bézier curve - Wikipedia</a></li><li><a href="https://en.wikipedia.org/wiki/Paul_de_Casteljau">Paul de Casteljau - Wikipedia</a></li><li><a href="https://en.wikipedia.org/wiki/Pierre_B%C3%A9zier">Pierre Bézier - Wikipedia</a></li><li><a href="https://en.wikipedia.org/wiki/Control_point_&#40;mathematics&#41;">Control point - Wikipedia</a></li><li><a href="https://en.wikipedia.org/wiki/Parametric_equation">Parametric curve - Wikipedia</a></li></ul>]]></content>
    
    
    <summary type="html">이 문서는 프런트개발에 있어서 유용하게 사용되는 베지에 곡선(Bezier Curves)의 원리를 수학적으로 자세히 소개하는 글의 두 번째 편입니다.</summary>
    
    
    
    <category term="Algorithm" scheme="http://blog.coderifleman.com/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="http://blog.coderifleman.com/tags/Algorithm/"/>
    
    <category term="BezierCurves" scheme="http://blog.coderifleman.com/tags/BezierCurves/"/>
    
    <category term="Spline" scheme="http://blog.coderifleman.com/tags/Spline/"/>
    
    <category term="Animation" scheme="http://blog.coderifleman.com/tags/Animation/"/>
    
    <category term="Math" scheme="http://blog.coderifleman.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>프런트엔드 엔지니어를 위한 베지에 곡선(Bezier Curves) - 1편</title>
    <link href="http://blog.coderifleman.com/2017/01/02/bezier-curves-for-frontend-engineer-1/"/>
    <id>http://blog.coderifleman.com/2017/01/02/bezier-curves-for-frontend-engineer-1/</id>
    <published>2017-01-01T15:00:00.000Z</published>
    <updated>2022-11-09T05:45:21.010Z</updated>
    
    <content type="html"><![CDATA[<p>퇴근 후 여느 때와 마찬가지로 PlayStation 4 전원에 손이 향하는 순간, 오랫동안 관리하지 못한 <a href="https://github.com/uyeong/react-preloader-icon">react-preloader-icon</a> 컴포넌트가 돌연 떠올랐다. react-preloader-icon은 <a href="http://samherbert.net/svg-loaders/">SVG Loaders</a>의 아이콘을 React 컴포넌트로 옮기고 있는 작은 사이즈의 프로젝트다.</p><p>SVG Loaders에 디자인된 아이콘은 12개밖에 안되지만 게으른 나머지 아직 2개밖에 옮기지 못했다. 그래서 게임은 잠시 제쳐두고 Spinning과 Puff 아이콘을 한번 React 컴포넌트로 옮겨보기로 했다.</p>    <figure title="Spinning과 Puff">      <a href="/images/bezier-curves-for-frontend-engineer-1/bezier-for-frontend.01.gif" target="_blank">        <img           src="/images/bezier-curves-for-frontend-engineer-1/bezier-for-frontend.01.gif"           alt="Spinning과 Puff"           style="max-width:340px"        >      </a>      <figcaption>&lt;그림 1. Spinning과 Puff&gt;</figcaption>    </figure>  <h2 id="SVG와-3차-베지에-곡선"><a href="#SVG와-3차-베지에-곡선" class="headerlink" title="SVG와 3차 베지에 곡선"></a>SVG와 3차 베지에 곡선</h2><p>Spinning 아이콘은 손쉽게 옮겼지만, Puff 아이콘은 좀 달랐다. 이전에 옮긴 아이콘 모두 애니메이션이 선형적(linear) 이기 때문에 신경 쓸 게 없었다. 하지만 Puff 아이콘의 SVG는 조금 다른 방식으로 만들어져 있다.</p><pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>svg</span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>44<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>44<span class="token punctuation">"</span></span> <span class="token attr-name">viewBox</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0 0 44 44<span class="token punctuation">"</span></span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2000/svg<span class="token punctuation">"</span></span> <span class="token attr-name">stroke</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#fff<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>g</span> <span class="token attr-name">fill</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>none<span class="token punctuation">"</span></span> <span class="token attr-name">fill-rule</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>evenodd<span class="token punctuation">"</span></span> <span class="token attr-name">stroke-width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>circle</span> <span class="token attr-name">cx</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>22<span class="token punctuation">"</span></span> <span class="token attr-name">cy</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>22<span class="token punctuation">"</span></span> <span class="token attr-name">r</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>animate</span> <span class="token attr-name">attributeName</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>r<span class="token punctuation">"</span></span>                <span class="token attr-name">begin</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0s<span class="token punctuation">"</span></span> <span class="token attr-name">dur</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1.8s<span class="token punctuation">"</span></span>                <span class="token attr-name">calcMode</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>spline<span class="token punctuation">"</span></span>                <span class="token attr-name">values</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1; 20<span class="token punctuation">"</span></span>                <span class="token attr-name">keyTimes</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0; 1<span class="token punctuation">"</span></span>                <span class="token attr-name">keySplines</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0.165, 0.84, 0.44, 1<span class="token punctuation">"</span></span>                <span class="token attr-name">repeatCount</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>indefinite<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>                ... 중략 ...        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>circle</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>g</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>svg</span><span class="token punctuation">></span></span></code></pre><p>위 코드에서 <code>animate</code> 엘리먼트를 살펴보자. 이 엘리먼트는 <code>calcMode</code>, <code>values</code>, <code>keyTimes</code>, <code>keySplines</code> 속성을 갖고 있다. 일단 이 속성에 관한 지식이 전혀 없기 때문에 우선 <a href="https://www.w3.org/TR/2001/REC-smil-animation-20010904/">SMIL</a> 스펙 문서를 살펴봤다.</p><p>스펙 문서를 통해 <code>calcMode</code>는 <strong>값의 타이밍을 제어할 함수</strong>를 선택하는 속성임을 알 수 있다. 속성 값으로 “discrete”, “linear”, “paced”, “spline” 중 하나를 지정할 수 있다.</p><p>위 코드의 <code>calcMode</code> 속성에는 “spline”이 지정돼 있는데 “spline”으로 지정하면 <code>values</code>, <code>keyTimes</code>, <code>keySplines</code> 속성과 함께 “<strong>3차 베지에 곡선</strong>“으로 값을 제어할 수 있다.</p><p>잠깐, “3차 베지에 곡선”이라고? 다들 CSS로 애니메이션을 처리할 때 cubic-bezier라는 애니메이션 타이밍 함수를 한 번쯤 사용해본 적이 있을 것이다. cubic-bezier… 그렇다. 3차 베지에라는 뜻이다.</p><h2 id="CSS와-3차-베지에-곡선"><a href="#CSS와-3차-베지에-곡선" class="headerlink" title="CSS와 3차 베지에 곡선"></a>CSS와 3차 베지에 곡선</h2><p>cubic-bezier 애니메이션 타이밍 함수는 x, y, x`, y` 즉, 4개의 값을 인자로 전달받아 에니메이션의 타이밍을 조절한다. x, y는 첫 번째 가이드 포인트(Guide Point)의 좌표, x`, y`은 두 번째 가이드 포인트의 좌표다. 가이드 포인트란 곡선의 형태에 영향을 주는 조절 가능한 점을 뜻한다.</p>    <figure title="3차 베지에 곡선의 가이드 포인트">      <a href="/images/bezier-curves-for-frontend-engineer-1/bezier-for-frontend.02.png" target="_blank">        <img           src="/images/bezier-curves-for-frontend-engineer-1/bezier-for-frontend.02.png"           alt="3차 베지에 곡선의 가이드 포인트"           style="max-width:340px"        >      </a>      <figcaption>&lt;그림 2. 3차 베지에 곡선의 가이드 포인트&gt;</figcaption>    </figure>  <p>3차 베지에 곡선이란 이 두 가이드 포인트의 위치에 따라 그려지는 곡선을 말한다. cubic-bezier는 이 곡선을 이용해 에니메이션의 타이밍을 조절한다(이 속성은 <a href="http://cubic-bezier.com/">cubic-bezier.com</a>, <a href="http://www.css3beziercurve.net/">CSS3 Bezier Curve Tester</a>, <a href="https://www.desmos.com/calculator/cahqdxeshd">desmos</a>에서 간단히 테스트해 볼 수 있다).</p>    <figure title="cubic-bezier를 이용해 선언한 Easing 함수 셋">      <a href="/images/bezier-curves-for-frontend-engineer-1/bezier-for-frontend.03.png" target="_blank">        <img           src="/images/bezier-curves-for-frontend-engineer-1/bezier-for-frontend.03.png"           alt="cubic-bezier를 이용해 선언한 Easing 함수 셋"           style="max-width:340px"        >      </a>      <figcaption>&lt;그림 3. cubic-bezier를 이용해 선언한 Easing 함수 셋&gt;</figcaption>    </figure>  <p>우리가 알고 있는 easeInSine, easeInQuad 등과 같은 Easing 함수(<a href="http://easings.net/ko#">참고</a>)는 모두 이 베지에 곡선을 이용해 미리 만든 일종의 셋이다.</p><h2 id="한걸음-더…"><a href="#한걸음-더…" class="headerlink" title="한걸음 더…"></a>한걸음 더…</h2><p>자, 본래 이야기로 다시 돌아와서… </p><p>SVG의 <code>calcMode=&quot;spline&quot;</code>의 의미를 살펴봤으니 <a href="https://www.npmjs.com/package/bezier-easing">bezier-easing</a>같은 npm 모듈을 사용해 Puff 아이콘을 React 컴포넌트로 옮기면 된다. 하지만 커밋을 완료하고 따듯한 이불 속에서 편안한 마음으로 잠자리에 들기엔 모르는 것이 너무나 많다. </p><p>왜 베지에 곡선이라 부를까? 무엇을 근거로 1차, 2차, 3차라고 나눌까? 또, 곡선이 그려지는 원리와 공식은 무엇일까? 몇 가지 물음이 잠 못 이루게 했고 결국 이 주제로 글을 작성하게 됐다. </p><p>그럼 다음 편부터 본격적으로 베지에 곡선에 관해서 연재하도록 하겠다.</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="http://qiita.com/volkuwabara/items/64d1ac2c3d8e8a3110f5">SCSS에서 사용할 cubic-bezier 값을 저장해두자(일본어)</a></li></ul>]]></content>
    
    
    <summary type="html">이 문서는 프런트개발에 있어서 유용하게 사용되는 베지에 곡선(Bezier Curves)의 원리를 수학적으로 자세히 소개하는 글의 첫 번째 편입니다.</summary>
    
    
    
    <category term="Algorithm" scheme="http://blog.coderifleman.com/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="http://blog.coderifleman.com/tags/Algorithm/"/>
    
    <category term="BezierCurves" scheme="http://blog.coderifleman.com/tags/BezierCurves/"/>
    
    <category term="Spline" scheme="http://blog.coderifleman.com/tags/Spline/"/>
    
    <category term="Animation" scheme="http://blog.coderifleman.com/tags/Animation/"/>
    
    <category term="Math" scheme="http://blog.coderifleman.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>중학생도 알 수 있는 베지에 곡선(Bezier Curves)</title>
    <link href="http://blog.coderifleman.com/2016/12/30/bezier-curves/"/>
    <id>http://blog.coderifleman.com/2016/12/30/bezier-curves/</id>
    <published>2016-12-29T15:00:00.000Z</published>
    <updated>2022-11-09T05:45:21.010Z</updated>
    
    <content type="html"><![CDATA[    <div class="alert alert--info">              <strong class="alert__title">          읽기전에...        </strong>            <div class="alert__body">        <p>이 문서는 일본어  「<a href="http://blog.sigbus.info/2011/10/bezier.html">中学生でもわかるベジェ曲線</a>」를 번역한 글입니다.</p>      </div>    </div>  <p>“베지에 곡선”을 이용해 렌더링하게 되면 꽤 재미있고 편안하게 그림을 그릴 수 있다. 오늘은 이를 사용하는 누구라도 그 원리를 이해할 수 있도록 설명하고자 한다.</p><p>“베지에 곡선”이라는 것은 매끄러운 곡선을 그리기 위한 것이지만 설명은 우선 단순한 직선부터 시작하겠다. 아래 그림 1 처럼 직선에서의 점의 움직임이 모든 “베지에 곡선”의 기본이 되기 때문이다.</p>    <figure title="1차 베지에 곡선">      <a href="/images/bezier-curves/bezier-curve.01.gif" target="_blank">        <img           src="/images/bezier-curves/bezier-curve.01.gif"           alt="1차 베지에 곡선"           style="max-width:300px"        >      </a>      <figcaption>&lt;그림 1. 1차 베지에 곡선&gt;</figcaption>    </figure>  <p>하나의 직선이 있고 그 위를 점 <code>M</code>이 일정 속도로 이동하고 있다. 이 점 <code>M</code>의 궤적은 당연하지만 단순한 직선으로 그려진다. 좋다. <code>t</code>는 <a href="http://dic.daum.net/word/view.do?wordid=kkw000140374&supid=kku000175471">선분</a> 위를 비율적으로 얼마나 나아갔는지를 나타내는 수치다.</p><p>여기에 선을 하나 더 추가하고 그 위에 <code>M</code>처럼 이동하는 점을 놓아보자. 그리고 원래의 점 <code>M</code>을 <code>M0</code>로, 새로운 점을 <code>M1</code>으로 부르자. <code>M0</code>와 <code>M1</code>이 움직이는 규칙은 이전과 같다. <code>M1</code>이라는 점이 하나 더 늘었다 하더라도 특별히 복잡해질 것은 없다.</p>    <figure title="2차 베지에 곡선">      <a href="/images/bezier-curves/bezier-curve.02.gif" target="_blank">        <img           src="/images/bezier-curves/bezier-curve.02.gif"           alt="2차 베지에 곡선"           style="max-width:300px"        >      </a>      <figcaption>&lt;그림 2. 2차 베지에 곡선&gt;</figcaption>    </figure>  <p>자, 여기에서 <code>M0</code>와 <code>M1</code>을 잇는 선을 하나 더 그을 수 있다. 그 선은 <code>M0</code>와 <code>M1</code>이 이동하면 자연스럽게 함께 움직이게 된다. 이제 그 선에 주목해보자. 그 선 위에 <code>M0</code>나 <code>M1</code>처럼 일정 속도로 이동하는 점을 놓을 수 있다. 그 점을 <code>B</code>라고 하자. 그리고 점 <code>B</code>가 그리는 궤적을 살펴보자. 그렇다. 점 <code>B</code>가 그리는 궤적을 **2차 베지에 곡선(Quadratic Bezier Curve)**이라고 한다.</p><p>점 <code>P0</code>, <code>P1</code> 등 을 조절점(Control Point)이라고 한다. 이제 조절점을 하나 더 늘린 “베지에 곡선”을 상상해보자.</p><p>아래 그림 3을 보면 새로운 점 <code>P3</code>가 추가돼 있고 <code>P2</code>와 <code>P3</code>를 선으로 잇고 있다. 그리고 <code>M0</code>나 <code>M1</code>과 같이 그 선 위를 이동하는 점을 생각해 볼 수 있다. 그 점의 이름은 <code>M2</code>라 하자.</p>    <figure title="3차 베지에 곡선">      <a href="/images/bezier-curves/bezier-curve.03.gif" target="_blank">        <img           src="/images/bezier-curves/bezier-curve.03.gif"           alt="3차 베지에 곡선"           style="max-width:300px"        >      </a>      <figcaption>&lt;그림 3. 3차 베지에 곡선&gt;</figcaption>    </figure>  <p>자, 2차 베이제 곡선에서는 <code>P0</code>, <code>P1</code>, <code>P2</code>의 조합으로 점 <code>B</code>의 위치를 정할 수 있었다. 그렇다면 마찬가지로 <code>P1</code>, <code>P2</code>, <code>P3</code>의 조합으로도 비슷하게 점의 위치를 정할 수 있을 것이다.</p><p>이전에 부르던 점 <code>B</code>를 <code>B0</code>라고 부르기로 하고 <code>P1</code>, <code>P2</code>, <code>P3</code>의 조합으로 정해지는 새로운 점을 <code>B1</code>이라고 부르기로 하자. 그렇게 하면 이전과 마찬가지로 점 <code>B0</code>와 점 <code>B1</code>을 잇는 선과 그 선 위를 일정한 속도로 움직이는 점을 다시 생각해 볼 수 있는데 이때 그 점이 그리는 궤적을 **3차 베지에 곡선(Cubic Bezier Curve)**이라고 한다.</p><p>여기에서 끝이 아니다. 조절점을 한 개 더 늘려 <code>P0</code>, <code>P1</code>, <code>P2</code>, <code>P3</code> 조합과 <code>P1</code>, <code>P2</code>, <code>P3</code>, <code>P4</code> 조합으로 결정되는 선과 그 선을 일정 속도로 이동하는 점 <code>B2</code>를 추가하고 <code>B1</code>과 <code>B2</code>를 잇는 선을 놓고 그 위를 지나가는 또 다른 점을 추가한 후 그 점이 그리는 궤적을 살펴볼 수 있다. 이런 식으로 곡선은 얼마든지 복잡하고 다양하게 만들 수 있다. <code>P0</code>부터 <code>P4</code>로 정해지는 곡선은 **4차 베지에 곡선(Quartic Bezier Curve)**이라고 부른다. 하지만 조절점을 5개 이상 늘려도 실용적인 측면에서 특별한 이점이 없으므로 일반적으로 3차 베지에 곡선까지 사용된다.</p><p>여기까지 간단하게 “베지에 곡선”에 관해 이야기했다. 한마디로 “베지에 곡선”이란 선분 위를 일정 속도로 움직이는 점과 그러한 점과 점을 잇는 또 다른 선분, 그리고 그 위를 일정 속도로 이동하는 또 다른 점 등을 조합해 최종적으로 특정 점이 그리는 궤적을 이용해 곡선을 그려내는 방법을 뜻한다. 이해하는 데 도움이 됐으리라 기대한다.</p>]]></content>
    
    
    <summary type="html">이 문서는 일본어 문서 「中学生でもわかるベジェ曲線」을 번역한 것으로 곡선을 그리거나 애니메이션 처리에 근간이 되는 베지에 곡선(Bezier Curves)의 원리에 관해서 쉽고 간단하게 소개합니다.</summary>
    
    
    
    <category term="Algorithm" scheme="http://blog.coderifleman.com/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="http://blog.coderifleman.com/tags/Algorithm/"/>
    
    <category term="BezierCurves" scheme="http://blog.coderifleman.com/tags/BezierCurves/"/>
    
    <category term="Spline" scheme="http://blog.coderifleman.com/tags/Spline/"/>
    
    <category term="Animation" scheme="http://blog.coderifleman.com/tags/Animation/"/>
    
    <category term="Math" scheme="http://blog.coderifleman.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>requestAnimationFrame을 어떻게 테스트 할 수 있을까?</title>
    <link href="http://blog.coderifleman.com/2016/12/02/how-to-test-request-animation-frame/"/>
    <id>http://blog.coderifleman.com/2016/12/02/how-to-test-request-animation-frame/</id>
    <published>2016-12-01T15:00:00.000Z</published>
    <updated>2022-11-09T05:45:21.011Z</updated>
    
    <content type="html"><![CDATA[<p>얼마전에 기능 개발을 하다가 애니메이션을 다룰 일이 생겼다. 처음엔 CSS를 이용했지만, IE8을 지원하고자 “<a href="https://github.com/chrisdickinson/raf">raf</a>“라는 폴리필 라이브러리를 이용해 <code>requestAnimationFrame</code>(이하 raf)으로 개발했다. raf의 대략적인 형태는 다음과 같다(API의 자세한 설명은 <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame">MDN의 window.requestAnimationFrame()</a>을 참고).</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> start <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">step</span><span class="token punctuation">(</span><span class="token parameter">timestamp</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>start<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    start <span class="token operator">=</span> timestamp<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">var</span> progress <span class="token operator">=</span> timestamp <span class="token operator">-</span> start<span class="token punctuation">;</span>  <span class="token comment">// Use progress to do something.</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>progress <span class="token operator">&lt;</span> <span class="token number">1500</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    window<span class="token punctuation">.</span><span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span>step<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>window<span class="token punctuation">.</span><span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span>step<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>코드를 보면 알겠지만 그렇게 직관적인 편은 아니다. raf를 쓸 때마다 이런 식으로 코드를 작성하긴 싫었다. 그래서 사용하기 편하게 raf를 랩핑한 객체 하나를 만들었다(여기서 시작한 작은 프로젝트가 있다 - <a href="https://github.com/UYEONG/stepperjs">StepperJS</a>).</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Stepper</span> <span class="token punctuation">&#123;</span>  <span class="token function">start</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>      duration <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>      easing <span class="token operator">=</span> linear<span class="token punctuation">,</span> <span class="token comment">// is easing function.</span>      <span class="token function-variable function">step</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token operator">=</span> options<span class="token punctuation">;</span>    <span class="token keyword">let</span> startTime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token function-variable function">stepping</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">timestamp</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>startTime<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        startTime <span class="token operator">=</span> timestamp<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">const</span> pastTime <span class="token operator">=</span> timestamp <span class="token operator">-</span> startTime<span class="token punctuation">;</span>      <span class="token keyword">const</span> progress <span class="token operator">=</span> pastTime <span class="token operator">/</span> duration<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>pastTime <span class="token operator">>=</span> duration<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">step</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token function">step</span><span class="token punctuation">(</span><span class="token function">easing</span><span class="token punctuation">(</span>progress<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      window<span class="token punctuation">.</span><span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span>stepping<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    window<span class="token punctuation">.</span><span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span>stepping<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>이렇게 작성한 Stepper 객체는 다음과 같이 사용할 수 있다.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> stepper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stepper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>stepper<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  duration<span class="token operator">:</span> <span class="token number">1500</span><span class="token punctuation">,</span>  <span class="token function-variable function">step</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    element<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token number">150</span> <span class="token operator">*</span> n<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">px</span><span class="token template-punctuation string">`</span></span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>    <p data-height="300" data-theme-id="0" data-slug-hash="yVpNLo" data-default-tab="result" data-user="uyeong" data-embed-version="2" data-pen-title="yVpNLo" class="codepen">      See the Pen <a href="http://codepen.io/uyeong/pen/yVpNLo/">yVpNLo</a> by Uyeong Ju (<a href="http://codepen.io/uyeong">@uyeong</a>) on <a href="http://codepen.io">CodePen</a>.    </p>  <p>개인적으로 생각했을 때 raf를 곧바로 사용하는 것보다 더 직관적이고 편해 보인다(물론 다른 의견을 가진 사람이 있을 수도 있다). 이제 Stepper 객체를 어떻게 테스트할 수 있을지 살펴보자.</p><p>Stepper는 지정한 <code>duration</code>과 <code>easing</code>에 따라 현재 시점에 해당하는 n 즉, progress 값을 콜백 함수에 전달하는 단순한 역할을 담당한다. 그렇다면 다음과 같이 테스트 케이스를 작성할 수 있을 것 같다.</p><blockquote><p>should call step callback with the current progress by duration and easing.</p></blockquote><p>음, 확실히 유닛 테스트로써는 손색없지만 필자는 사용자 관점에서 서술하는 걸 좋아하니 이렇게 고쳐보자.</p><blockquote><p>The user should be able to know the current progress through the start method of Stepper</p></blockquote><p>이를 어떻게 검증할 수 있을까? 필요한 값을 설정하고 start 메서드를 호출한 후 특정 시간으로 옮긴(tick) 다음 “n”이 기대하는 값과 일치하는지 확인하면 될 것 같다. 한번 테스트 코드로 옮겨보자.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'The user should be able to know the current progress through the start method of Stepper'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">assert</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token comment">// Given</span>  <span class="token keyword">const</span> stepper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stepper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> duration <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> easing <span class="token operator">=</span> linear<span class="token punctuation">;</span>  <span class="token keyword">let</span> progress<span class="token punctuation">;</span>    <span class="token comment">// When</span>  stepper<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    duration<span class="token punctuation">,</span>    easing<span class="token punctuation">,</span>    <span class="token function-variable function">step</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token operator">=></span> progress <span class="token operator">=</span> n  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Then</span>  <span class="token function">assert</span><span class="token punctuation">(</span>progress <span class="token operator">===</span> <span class="token operator">??</span><span class="token operator">?</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>다른 조건들은 어려울 게 없지만, 특정 시간으로 옮기는 행위는 그렇지 않다. 함수를 호출하는 순간 시간은 흘러 버리므로 특정 시간에 해당하는 progress 값을 비교할 수 없다.</p><p>이처럼 테스트 환경에서 시간을 조작하고 싶을 때 사용할 수 있는 테스트 더블 라이브러리가 있다. 바로 “<a href="http://sinonjs.org/docs/">sinon</a>“이다. <a href="http://sinonjs.org/docs/#clock">sinon의 FakeTimer</a>는 <code>setTimeout</code>과 <code>Date</code> 객체 등을 덮어써서 동기적으로 시간을 조작할 수 있는 수단을 제공한다. 이것을 사용해보자.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> clock <span class="token operator">=</span> sinon<span class="token punctuation">.</span><span class="token function">useFakeTimers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'The user should be able to know the current progress through the start method of Stepper'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">assert</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Given</span>    <span class="token keyword">const</span> stepper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stepper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> duration <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> easing <span class="token operator">=</span> linear<span class="token punctuation">;</span>    <span class="token keyword">const</span> step <span class="token operator">=</span> sinon<span class="token punctuation">.</span><span class="token function">spy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// When</span>    stepper<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>        duration<span class="token punctuation">,</span>        easing<span class="token punctuation">,</span>        step    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    clock<span class="token punctuation">.</span><span class="token function">tick</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    clock<span class="token punctuation">.</span><span class="token function">tick</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Then</span>    <span class="token function">assert</span><span class="token punctuation">(</span>step<span class="token punctuation">.</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">linear</span><span class="token punctuation">(</span><span class="token number">250</span> <span class="token operator">/</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>    <p data-height="300" data-theme-id="0" data-slug-hash="PbEaMp" data-default-tab="result" data-user="uyeong" data-embed-version="2" data-pen-title="PbEaMp" class="codepen">      See the Pen <a href="http://codepen.io/uyeong/pen/PbEaMp/">PbEaMp</a> by Uyeong Ju (<a href="http://codepen.io/uyeong">@uyeong</a>) on <a href="http://codepen.io">CodePen</a>.    </p>  <p>당연한 얘기겠지만 <code>TypeError</code>가 발생한다. raf는 시간이 아닌 <code>repaint</code> 시점을 기준으로 호출되며 독자적으로 타임스템프를 계산해 콜백에 전달하므로 sinon의 FakeTimer로 조작할 수 없다. 따라서 동기적으로 호출한 <code>args</code> 프로퍼티에 쌓인 값이 없으므로 에러가 발생하는 것이다.</p><p>그렇다면 어떻게 해야 할까. 고맙게도 누군가 raf를 Stub한 “<a href="https://github.com/alexreardon/raf-stub">raf-stub</a>“을 개발해 배포해놨다. 이 Stub을 사용해 테스트를 다시 작성해보자.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> stub <span class="token operator">=</span> <span class="token function">createStub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sinon<span class="token punctuation">.</span><span class="token function">stub</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> <span class="token string">'requestAnimationFrame'</span><span class="token punctuation">,</span> stub<span class="token punctuation">.</span>add<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'The user should be able to know the current progress through the start method of Stepper'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">assert</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Given</span>    <span class="token keyword">const</span> stepper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stepper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> duration <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> easing <span class="token operator">=</span> linear<span class="token punctuation">;</span>    <span class="token keyword">const</span> step <span class="token operator">=</span> sinon<span class="token punctuation">.</span><span class="token function">spy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// When</span>    stepper<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>        duration<span class="token punctuation">,</span>        easing<span class="token punctuation">,</span>        step    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    stub<span class="token punctuation">.</span><span class="token function">step</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    stub<span class="token punctuation">.</span><span class="token function">step</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Then</span>    <span class="token function">assert</span><span class="token punctuation">(</span>step<span class="token punctuation">.</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">linear</span><span class="token punctuation">(</span><span class="token number">250</span> <span class="token operator">/</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>    <p data-height="300" data-theme-id="0" data-slug-hash="LbeJZz" data-default-tab="result" data-user="uyeong" data-embed-version="2" data-pen-title="LbeJZz" class="codepen">      See the Pen <a href="http://codepen.io/uyeong/pen/LbeJZz/">LbeJZz</a> by Uyeong Ju (<a href="http://codepen.io/uyeong">@uyeong</a>) on <a href="http://codepen.io">CodePen</a>.    </p>  <p>테스트가 통과한다. raf를 사용해 작성한 코드를 테스트하려고 할 때 다소 막막할 수 있다. 하지만 sinon과 Stub을 적절히 사용한다면 손쉽게 테스트할 수 있다.</p><p>여기까지 raf를 테스트하는 방법을 소개했다. 비슷한 고민을 하는 사람에게 작은 팁으로나마 도움이 되길 바라며 예제 코드는 <a href="https://github.com/UYEONG/request-animation-frame-test">UYEONG/request-animation-frame-test</a>에 올려놓았으니 참고하길 바란다.</p>]]></content>
    
    
    <summary type="html">requestAnimationFrame을 사용해 작성한 코드를 어떻게 유닛 테스트(Unit Test)할 수 있는지 단계별로 자세히 소개합니다.</summary>
    
    
    
    <category term="JavaScript" scheme="http://blog.coderifleman.com/categories/JavaScript/"/>
    
    <category term="Test" scheme="http://blog.coderifleman.com/categories/JavaScript/Test/"/>
    
    
    <category term="Test" scheme="http://blog.coderifleman.com/tags/Test/"/>
    
    <category term="UnitTest" scheme="http://blog.coderifleman.com/tags/UnitTest/"/>
    
    <category term="Animation" scheme="http://blog.coderifleman.com/tags/Animation/"/>
    
    <category term="JavaScript" scheme="http://blog.coderifleman.com/tags/JavaScript/"/>
    
    <category term="requestAnimationFrame" scheme="http://blog.coderifleman.com/tags/requestAnimationFrame/"/>
    
  </entry>
  
  <entry>
    <title>history 객체의 scrollRestoration 속성</title>
    <link href="http://blog.coderifleman.com/2016/11/28/scroll-restoration-property-of-history/"/>
    <id>http://blog.coderifleman.com/2016/11/28/scroll-restoration-property-of-history/</id>
    <published>2016-11-27T15:00:00.000Z</published>
    <updated>2022-11-09T05:45:21.014Z</updated>
    
    <content type="html"><![CDATA[<p>특정 목록 페이지에 접근할 때 사용자가 마지막으로 클릭했던 아이템이 보이도록 자동 스크롤링 해달라는 요청이 들어왔다. 개인적으로 <code>onload</code> 타임에 특정 목록으로 자동 스크롤링하는 기능은 지양해 왔기 때문에 웹이 가진 한계점을 설명하면서 간단히 프로토타이핑해본 후 판단하자고 의견을 냈다.</p><p>그런데 프로토타이핑하던 도중 예전엔 경험하지 못했던 이상한 현상이 발견됐다. 아래는 사용자가 마지막으로 클릭한 아이템이 “product30” 이라고 보고 해당하는 엘리먼트의 위치로 스크롤링하는 간단한 코드다.</p><pre class="language-js" data-language="js"><code class="language-js">window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'load'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'onloaded'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> product30 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token string">'product-item'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> top <span class="token operator">=</span> product30<span class="token punctuation">.</span><span class="token function">getBoundingClientRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>top<span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">scroll to </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>top<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">(product30)</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>    window<span class="token punctuation">.</span><span class="token function">scrollTo</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> top<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>생각한 대로라면 지정한 위치로 스크롤링 되어야 하지만 동작하지 않았다. 아래 “그림 1”을 보면 분명히 <code>9970.875</code> 즉, “product30”의 위치로 스크롤링을 지시했음에도 문서는 여전히 최상단에 있음을 알 수 있다.</p>    <figure title="동작하지 않는 scrollTo()">      <a href="/images/scroll-restoration-property-of-history/scroll.01.png" target="_blank">        <img           src="/images/scroll-restoration-property-of-history/scroll.01.png"           alt="동작하지 않는 scrollTo()"           style=""        >      </a>      <figcaption>&lt;그림 1. 동작하지 않는 scrollTo()&gt;</figcaption>    </figure>  <p>간단한 코드로 재현하긴 힘들지만, 실제 서비스 페이지에서는 <code>setTimeout(() =&gt; ..., 0)</code>으로 지정해도 금세 원래의 위치로 크롬이 재보정한다.</p><p> 이렇게 동작하는 이유는 크롬이 사용자가 보고 있던 스크롤 위치를 저장하고 있다가 해당 페이지에 다시 접근하면 브라우저 레벨에서 자동으로 스크롤링하기 때문인데 어떻게 해야 이를 회피할 수 있을지 고민됐다. 이때 <a href="http://sculove.github.io/blog/">찬욱</a>님에게 여쭤보니 아래와 같은 코드로 이를 무력화할 수 있다는 답변을 받았다.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'scrollRestoration'</span> <span class="token keyword">in</span> history<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Back off, browser, I got this...</span>    history<span class="token punctuation">.</span>scrollRestoration <span class="token operator">=</span> <span class="token string">'manual'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>위 코드를 삽입하고 다시 페이지에 접근하니 정확히 의도한 대로 동작했다.</p>    <figure title="제대로 동작하는 scrollTo()">      <a href="/images/scroll-restoration-property-of-history/scroll.02.png" target="_blank">        <img           src="/images/scroll-restoration-property-of-history/scroll.02.png"           alt="제대로 동작하는 scrollTo()"           style=""        >      </a>      <figcaption>&lt;그림 2. 제대로 동작하는 scrollTo()&gt;</figcaption>    </figure>  <p>프로토타이핑은 무사히 완료했고 의사 결정하는데 큰 역할을 했다. 하지만 이렇게 이야기를 마무리하기엔 찜찜하다. <code>scrollRestoration</code> 속성을 좀 이해하고 넘어가야 할 것 같다.</p><p>필자는 이번에 <code>scrollRestoration</code>이라는 속성을 처음 봤다. 그도 그럴 것이 <code>scrollRestoration</code>은 실험적(Experimental) API 에다가 아직 MDN에 페이지도 없고(<a href="https://developer.mozilla.org/ko/docs/Web/API/History/scrollRestoration">참고</a>), 2015년 10월에 배포된 크롬 46에서야 추가된 API다.</p><p><code>scrollRestoration</code>은 히스토리 네비게이션의 스크롤 복원 기능을 명시적으로 지정할 수 있는 속성이다. 속성값은 ‘auto’와 ‘manual’이 전부. SPA 환경과 관련이 있어 보인다. 이 글을 읽는 사람 중 대다수는 목록 페이지에서 특정 아이템을 클릭해 엔드 페이지로 갔다가 다시 되돌아오면 스크롤을 처음부터 다시 해야 하는 경험을 한 적 있을 것 같다. 그래서 스크롤 포지션 값을 <code>LocalStorage</code>에 저장했다가 다시 목록 페이지에 접근하면 억지로 스크롤 위치를 잡아주는 기능을 구현한다.</p><p>대표적으로 네이버 주식 모바일 웹이 그런 방식으로 구현돼 있는데 토론 목록 페이지에서 토론 페이지로 접근하면 <code>scrollY</code> 값을 기억해 뒀다가,  뒤로 가기 하여 토론 목록 페이지로 되돌아오면 이 값을 이용해 스크롤 위치를 조절한다.</p>    <figure title="보던 목록으로 스크롤링하기 위해 scrollY 값을 기억한다">      <a href="/images/scroll-restoration-property-of-history/scroll.03.png" target="_blank">        <img           src="/images/scroll-restoration-property-of-history/scroll.03.png"           alt="보던 목록으로 스크롤링하기 위해 scrollY 값을 기억한다"           style=""        >      </a>      <figcaption>&lt;그림 3. 사용자가 보던 곳으로 보정하기 위해 scrollY 값 저장&gt;</figcaption>    </figure>  <p>위와 같은 구현 방식은 사용자가 정확히 어느 경로를 통해 목록 페이지로 접근하는지 알기 어려워 자칫 잘못된 경험을 제공(검색을 통해 접근했는데 스크롤 위치를 조절하는 등)하기도 하는데 <code>scrollRestoration</code>은 history navigation을 기반으로 동작하기 때문에 이러한 부분을 해소할 수 있을 것으로 보인다. 하지만 처음에 이야기한 것처럼 자동 스크롤링 기능이 오히려 특정 기능 구현에 방해가 될 수도 있는데 세심하게 개발자에게 조절할 수 있도록 속성을 열어줘서 고마울 따름.</p><p>테스트 코드는 <a href="https://github.com/UYEONG/scroll-restoration-test">UYEONG/scroll-restoration-test</a>에 올려놓았으니 참고하길 바란다.</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/History">History - Web APIs</a></li><li><a href="https://developers.google.com/web/updates/2015/09/history-api-scroll-restoration">History API: Scroll Restoration</a></li><li><a href="https://majido.github.io/scroll-restoration-proposal/history-based-api.html">Custom Scroll Restoration - History-based API</a></li></ul>]]></content>
    
    
    <summary type="html">onload 타임에 특정 위치에 자동 스크롤링 되는 기능을 프로토타이핑 하면서 마주한 문제와 history 객체의 scrollRestoration 속성으로 해결한 과정을 소개합니다.</summary>
    
    
    
    <category term="JavaScript" scheme="http://blog.coderifleman.com/categories/JavaScript/"/>
    
    <category term="Etc" scheme="http://blog.coderifleman.com/categories/JavaScript/Etc/"/>
    
    
    <category term="JavaScript" scheme="http://blog.coderifleman.com/tags/JavaScript/"/>
    
    <category term="history" scheme="http://blog.coderifleman.com/tags/history/"/>
    
    <category term="scrollRestoration" scheme="http://blog.coderifleman.com/tags/scrollRestoration/"/>
    
  </entry>
  
  <entry>
    <title>첫 인상이 좋은 E2E 테스트 프레임워크, TestCafe</title>
    <link href="http://blog.coderifleman.com/2016/10/31/good-first-impression-testcafe/"/>
    <id>http://blog.coderifleman.com/2016/10/31/good-first-impression-testcafe/</id>
    <published>2016-10-30T15:00:00.000Z</published>
    <updated>2022-11-09T05:45:21.011Z</updated>
    
    <content type="html"><![CDATA[<p>인생을 살다 보면 괴롭지만 꼭 해야만 하는 일을 만나게 된다. 프런트엔드개발자에겐 그런 일 중 하나가 바로 UI 테스트가 아닐까 싶은데, 이 고통스러운 일을 조금이나마 덜어줄 잘 만들어진 도구나 프레임워크를 찾지만 쉽지 않다. 처음엔 좋아 보여도 실제 테스트를 작성하다 보면 금세 그 도구가 가진 한계점을 만나게 된다. 그래서 그런지 다른 일보다도 더욱 도구에 의존하게 되고 개선된 또 다른 도구를 찾게 되는 것 같다.</p><p><a href="http://devexpress.github.io/testcafe/">TestCafe</a>는 자바스크립트 소식을 매주 정리해 공유하는 사이트인 <a href="https://jser.info/">JSer.info</a>의 <a href="https://jser.info/2016/10/24/npm-4.0.0-node.js-v6.9.0-lts-webpack2/">2016년 10월 24일 자 소식</a>을 통해 알게 됐다. 해당 문서에 링크된 <a href="http://efcl.info/2016/10/23/testcafe/">TestCafe로 브라우저 자동 테스트(일본어)</a>를 읽어보았는데 생각보다 느낌이 좋아서 한번 리뷰해보자는 결론을 내렸다.</p><h2 id="TestCafe-소개"><a href="#TestCafe-소개" class="headerlink" title="TestCafe 소개"></a>TestCafe 소개</h2><p>TestCafe는 <a href="https://www.devexpress.com/">DevExpress</a>가 개발한 E2E 테스트 프레임워크다. InfoQ에 TestCafe와 관련된 인터뷰 글(<a href="https://www.infoq.com/news/2013/08/testcafe">TestCafe with Smart Script Injection, Traffic and Markup Analysis Tools</a>)이 있으니 관심 있는 사람은 참고하길 바란다. 같은 이름의 <a href="https://testcafe.devexpress.com/">웹 서비스 및 클라이언트 앱</a>도 서비스 중인데 이 서비스는 셀레니움 IDE 처럼 GUI로 조작하고 행위를 기록하여 재생할 수 있다.</p><p>TestCafe는 <a href="http://webdriver.io/">webdriber.io</a>나 <a href="http://nightwatchjs.org/">나이트왓치</a>와는 다르게 테스트 관련 스크립트를 주입해 동작하는 셀레니움 RC(Selenium RC)와 흡사한 방식으로 개발됐다. 사실 셀레니움 RC가 가진 한계를 극복하고자 셀레니움 웹드라이버(Selenium WebDriver)를 개발했는데 다시 셀레니움 RC와 비슷한 구조로 테스트 프레임워크를 만들었다고 해서 “그렇다면 과거에 경험했던 한계를 그대로 답습하는 게 아닌가?”하고 조금 의아했다. </p><p>TestCafe의 개발자 <a href="https://github.com/inikulin">이반 니쿨린(Ivan Nikulin)</a>은 <a href="https://testcafe-discuss.devexpress.com/t/why-not-use-selenium/47">Why not use Selenium?</a>에서 그 이유를 밝혔는데 간단히 말해서 테스트 환경에 대한 복잡한 설정 없이 실행할 수 있고, 모바일 기기에서도 원격 접속해 테스트할 수 있는 도구를 만들고 싶어 했던 거 같다. 또, 웹드라이버의 호환성 문제를 회피하기 위한 목적도 있는 것 같다.</p><p>셀레니움은 분명 훌륭한 도구지만 설정이 복잡하고 웹드라이버 자체의 버그로 인해 테스트 작성에 종종 걸림돌이 되는 경우가 있다. 또 테스트 코드 자체를 디버깅하기가 까다로워 복잡한 테스트 케이스를 작성하는데 어려운 면도 가지고 있다. 과거 셀레니움 RC 방식에 한계가 있어 셀레니움을 만들었지만 새로운 문제들이 나타났다. 이러한 상황에서 TestCafe의 지향점이 좋은 해결책이 될 수 있을까?</p><h2 id="좋은-인상"><a href="#좋은-인상" class="headerlink" title="좋은 인상"></a>좋은 인상</h2><p>필자는 유료 웹툰을 서비스하고 있는 <a href="http://www.lezhin.com/">레진(Lezhin)</a>을 이용해 로그인 테스트를 작성해 봤다. 예제 코드는 저장소 <a href="https://github.com/UYEONG/demo-testcafe">UYEONG/demo-testcafe</a>를 참고한다. 이번 절에서는 이 예제를 이용해 필자가 받은 몇 가지 좋은 인상을 소개하겠다.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'사용자는 GNB 메뉴에서 로그인할 수 있다.'</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">t</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Given</span>    <span class="token keyword">const</span> popupAttendanceLogin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PopupAttendanceLogin</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">await</span> popupAttendanceLogin<span class="token punctuation">.</span><span class="token function">exist</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">await</span> popupAttendanceLogin<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">await</span> t        <span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token string">'#main-menu-toggle'</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">typeText</span><span class="token punctuation">(</span><span class="token string">'#login-email'</span><span class="token punctuation">,</span> <span class="token constant">ACCOUNT</span><span class="token punctuation">.</span><span class="token constant">USER_NAME</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">typeText</span><span class="token punctuation">(</span><span class="token string">'#login-password'</span><span class="token punctuation">,</span> <span class="token constant">ACCOUNT</span><span class="token punctuation">.</span><span class="token constant">PASSWORD</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// When</span>    <span class="token keyword">await</span> t        <span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token string">'form.login-form button[type=submit]'</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Then</span>    <span class="token keyword">await</span> t<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token string">'#main-menu-toggle'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> email <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getElement</span><span class="token punctuation">(</span><span class="token string">'sidenav-email'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>email<span class="token punctuation">.</span>visible<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>email<span class="token punctuation">.</span>innerText <span class="token operator">===</span> <span class="token constant">ACCOUNT</span><span class="token punctuation">.</span><span class="token constant">USER_NAME</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>위는 레진에서 GNB 메뉴를 이용해 로그인이 정상적으로 이뤄지는지 테스트하는 코드다. 그리고 이 코드는 <code>await/async</code>를 이용해 비동기적 절차를 동기적으로 표현하고 있다. TestCafe는 바벨(Babel)을 내장하고 있어 별도의 설정 없이 최신 사양을 이용할 수 있다. 최신 사양으로 코드를 작성하고자 할 때 복잡한 세팅을 해줘야 하는 기존의 테스트 프레임워크와는 다른 부분이다. </p>    <figure title="TestCafe에서 디버깅하기">      <a href="/images/good-first-impression-testcafe/testcafe.01.gif" target="_blank">        <img           src="/images/good-first-impression-testcafe/testcafe.01.gif"           alt="TestCafe에서 디버깅하기"           style=""        >      </a>      <figcaption>&lt;그림 1. TestCafe에서 디버깅하기&gt;</figcaption>    </figure>  <p>또, <code>await/async</code> 방식으로 테스트 코드를 작성하면 디버깅이 쉽다는 장점이 있는데 체이닝을 펼치기 쉬우므로 각 액션을 단계별로 관찰할 수 있다. 나이트왓치는 파이프라인 방식으로 디자인돼 있어 디버깅이 다소 까다롭다.</p><p>그럼 이제 실행을 해보자. 해당 저장소를 클론하고 다음 명령어를 입력하면 바로 테스트할 수 있다.</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> clone git@github.com:UYEONG/demo-testcafe.git$ <span class="token function">npm</span> <span class="token function">install</span>$ <span class="token function">npm</span> run <span class="token builtin class-name">test</span></code></pre><p><code>npm scripts</code>에 등록한 <code>test</code> 명령은 다음과 같다. </p><pre class="language-bash" data-language="bash"><code class="language-bash">$ testcafe chrome tests/</code></pre><p>뭔가 추가적인 설정이 없으니 오히려 불안하다. 하지만 그 안락함에 금방 익숙해진다. 이것저것 세팅해줘야 했던 셀레니움 기반 프레임워크(<a href="http://blog.coderifleman.com/2016/06/17/e2e-test-and-nightwatch/#%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0">참고</a>)와는 사뭇 다른 경험이다.</p>    <figure title="로그인 테스트 실행 결과">      <a href="/images/good-first-impression-testcafe/testcafe.02.gif" target="_blank">        <img           src="/images/good-first-impression-testcafe/testcafe.02.gif"           alt="로그인 테스트 실행 결과"           style=""        >      </a>      <figcaption>&lt;그림 2. 로그인 테스트 실행 결과&gt;</figcaption>    </figure>  <p>그림 2는 로그인 테스트가 진행되는 모습이다. 이 테스트의 진행 절차는 다음과 같다.</p><ol><li><a href="http://www.lezhin.com/">www.lezhin.com</a> 페이지에 접근한다. </li><li>최초에 출력된 팝업이 있다면 닫는다.</li><li>우측 상단의 메뉴 버튼을 클릭한다.</li><li>이메일 / 패스워드를 입력하고 로그인 버튼을 선택한다.</li><li>페이지가 갱신되면 다시 우측 상단의 메뉴 버튼을 클릭한다.</li><li>로그인이 정상적으로 완료 됐는지 확인한다.</li></ol><p>특정 절차에서 다음 절차로 넘어가기 위해선 지연 시간(Delay time)이 필요하다. 예를 들어 최초 페이지에 접근할 때는 콘텐츠가 모두 출력되는 시점을 기다려야 하고 팝업을 닫을 때는 애니메이션(FadeOut)이 종료되는 시간을 기다려야 한다. 나이트왓치에서는 이런 지연 시간을 직접 명시해줘야 한다.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 페이지에 최초 접근 시 body 엘리먼트가 보일 때까지 5000ms 기다린다.</span><span class="token keyword">this</span><span class="token punctuation">.</span>_header    <span class="token punctuation">.</span><span class="token function">navigate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">waitForElementVisible</span><span class="token punctuation">(</span><span class="token string">'body'</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 팝업을 닫을때 애니메이션 시간을 고려해 500ms 기다린다.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token string">'@close'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>api<span class="token punctuation">.</span><span class="token function">pause</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>하지만 TestCafe를 이용할 땐 지연 시간을 직접 입력할 일이 상대적으로 적다. TestCafe는 지연 시간을 직접 계산하고 관리한다. 실제로 위 로그인 테스트 코드를 보면 지연 시간을 명시한 지점은 로그인 버튼을 클릭한 시점 즉, 폼을 서브밋하고 갱신되기를 기다리는 딱 한 곳뿐이다.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">await</span> t    <span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token string">'form.login-form button[type=submit]'</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>지연 시간이라고 해도 거의 대충 시간을 짐작해 입력하는 일에 불과하다. 물론 비기능적 요구사항도 테스트에 포함돼야 하지만 애니메이션 종료 시점까지 일일이 명시해야 한다는 것은 분명 귀찮은 일이다. </p><p>그리고 이벤트 지점을 커서로 표현해주거나 실제 타이핑을 하는 느낌을 살려 텍스트를 입력하는 부분도 인상적이다. 셀레니움 기반 테스트 프레임워크는 이런 자연스러운 느낌이 상대적으로 적다.</p>    <figure title="TestCafe의 에러 리포팅">      <a href="/images/good-first-impression-testcafe/testcafe.03.png" target="_blank">        <img           src="/images/good-first-impression-testcafe/testcafe.03.png"           alt="TestCafe의 에러 리포팅"           style=""        >      </a>      <figcaption>&lt;그림 3. TestCafe의 에러 리포팅&gt;</figcaption>    </figure>  <p>마지막으로 에러 리포팅도 상당히 깔끔한 편인데 어느 지점에서 어떠한 에러가 낫는지 알기 쉽게 출력해준다. 그림 3을 보면 24번째 행의 코드에 문제가 있음을 쉽게 알 수 있다.</p><p>구구절절 설명했지만 TestCafe를 리뷰하면서 좋은 인상을 받은 점을 간단히 정리하면 다음과 같다.</p><ul><li>바벨을 내장하고 있어서 특별한 설정 없이 ES6+ 사양을 사용할 수 있다.</li><li>테스트 코드 디버깅이 상대적으로 쉽다.</li><li>특별한 설정 없이 커멘드 라인 명령으로 바로 테스트할 수 있다.</li><li>특정 조작에 대한 지연 시간을 자동으로 관리한다.</li><li>테스트 실패 및 에러 리포팅이 깔끔한 편이다.</li></ul><h2 id="아쉬운-점"><a href="#아쉬운-점" class="headerlink" title="아쉬운 점"></a>아쉬운 점</h2><p>분명 기존의 E2E 테스트 프레임워크보다 몇 가지 좋은 인상을 가지고 있는건 분명하다. 하지만 아쉬운 점도 있다. 일단 다양한 상황을 테스트하기엔 액션 셋과 API가 부족하다. </p>    <figure title="TestCafe와 그 외 프레임워크의 API 목록">      <a href="/images/good-first-impression-testcafe/testcafe.04.png" target="_blank">        <img           src="/images/good-first-impression-testcafe/testcafe.04.png"           alt="TestCafe와 그 외 프레임워크의 API 목록"           style=""        >      </a>      <figcaption>&lt;그림 4. TestCafe와 그 외 프레임워크의 API 목록&gt;</figcaption>    </figure>  <p>왼쪽 부터 차례대로 TestCafe, 나이트왓치, webdriver.io 가 제공하고 있는 액션 및 API 목록이다. 기본적인 액션은 제공하지만, 모바일에 특화된 액션이나 스크립트 권한 밖의 액션 등은 이용하기 힘들다. 시간이 지나면서 제공될 수 있는 API도 있지만 TestCafe가 가지고 있는 구조적 한계로 인해 아예 불가능한 API도 있다.</p><p>또, E2E 테스트를 할 때 좋은 패턴들이 있는데 그중 하나가 <code>PageObject</code>다. 테스트에 필요한 반복적인 행위나 엘리먼트 셀렉터 등을 밖으로 노출 시키지 않고 페이지 단위(혹은 컴포넌트 단위)로 추상화해 제공할 수 있다(<a href="http://nightwatchjs.org/guide#page-objects">참고</a>). <code>PageObject</code>는 테스트 코드의 가독성이나 유지 보수 측면에서 훌륭한 패턴이지만 TestCafe에서는 제공하지 않는다. </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// page-objects/popup-attendance-login.js</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>Selector<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'testcafe'</span><span class="token punctuation">;</span> <span class="token keyword">const</span> querySelector <span class="token operator">=</span> <span class="token function">Selector</span><span class="token punctuation">(</span><span class="token parameter">q</span> <span class="token operator">=></span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">class</span> <span class="token class-name">PopupAttendanceLogin</span> <span class="token punctuation">&#123;</span>    elements <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        wrapper<span class="token operator">:</span> <span class="token string">'#popup-attendance-login'</span><span class="token punctuation">,</span>        closeBtn<span class="token operator">:</span> <span class="token string">'#popup-attendance-login .attlogin__close'</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">testController</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>t <span class="token operator">=</span> testController<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">async</span> <span class="token function">exist</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">const</span> wrapper <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>elements<span class="token punctuation">.</span>wrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> wrapper<span class="token punctuation">.</span>visible<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">async</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">const</span> closeBtn <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>elements<span class="token punctuation">.</span>closeBtn<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>t<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span>closeBtn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">export</span> <span class="token keyword">default</span> PopupAttendanceLogin<span class="token punctuation">;</span><span class="token comment">// tests/signin-test.js</span><span class="token keyword">import</span> PopupAttendanceLogin <span class="token keyword">from</span> <span class="token string">'../page-objects/popup-attendance-login'</span><span class="token punctuation">;</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'사용자는 GNB 메뉴에서 로그인할 수 있다.'</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">t</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Given</span>    <span class="token keyword">const</span> popupAttendanceLogin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PopupAttendanceLogin</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">await</span> popupAttendanceLogin<span class="token punctuation">.</span><span class="token function">exist</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">await</span> popupAttendanceLogin<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// ... 생략 ...</span></code></pre><p>그래서 필자는 위 코드처럼 직접 <code>PageObject</code>와 비슷한 객체를 직접 만들고 테스트 코드를 작성했다. 만약 프레임워크 자체에서 이 개념을 제공한다면 조금 더 편리하게 코드를 작성할 수 있을 것 같다.</p><h2 id="끝으로"><a href="#끝으로" class="headerlink" title="끝으로"></a>끝으로</h2><p>여기까지 TestCafe를 소개하고 필자가 느낀 좋은 인상과 아쉬운 점을 함께 이야기했다. 이 도구가 우리의 UI 테스트 환경의 답이 돼 줄 것이라 생각하지 않는다. 분명 실제로 테스트를 작성하기 시작하면 온갖 버그와 미흡한 점을 만나게 될 것이다. 하지만 아직 시작된 지 얼마 안 된 프로젝트라는 점을 미루어 볼 때 차차 개선될 것이라고 긍정적으로 생각할 수 있다. </p><p>중요한 건 그들이 어떤 문제를 해결하고 싶어 하고 어디에 지향점을 두고 있느냐다. 그것이 내 앞에 놓인 문제 혹은 환경과 맞아떨어진다면 더할 나위 없는 좋은 도구가 될 것이다.</p>]]></content>
    
    
    <summary type="html">E2E 테스트 프레임워크의 한 종류인 TestCafe를 소개하고 사용 방법과 또 다른 E2E 테스트 프레임워크인 나이트왓치와의 차이점을 간략하게 살펴본다.</summary>
    
    
    
    <category term="JavaScript" scheme="http://blog.coderifleman.com/categories/JavaScript/"/>
    
    <category term="Test" scheme="http://blog.coderifleman.com/categories/JavaScript/Test/"/>
    
    
    <category term="Test" scheme="http://blog.coderifleman.com/tags/Test/"/>
    
    <category term="E2E" scheme="http://blog.coderifleman.com/tags/E2E/"/>
    
    <category term="E2E Test" scheme="http://blog.coderifleman.com/tags/E2E-Test/"/>
    
    <category term="TestCafe" scheme="http://blog.coderifleman.com/tags/TestCafe/"/>
    
  </entry>
  
  <entry>
    <title>공학기술과 사회를 읽고</title>
    <link href="http://blog.coderifleman.com/2016/10/11/read-the-engineering-technology-and-society/"/>
    <id>http://blog.coderifleman.com/2016/10/11/read-the-engineering-technology-and-society/</id>
    <published>2016-10-10T15:00:00.000Z</published>
    <updated>2022-11-09T05:45:21.013Z</updated>
    
    <content type="html"><![CDATA[<p>나는 소프트웨어 엔지니어다. 이 일로 돈을 벌고 가족을 책임지지만 여전히 엔지니어링 즉, 공학이란 무엇이냐는 단순한 질문에도 쉽게 대답하지 못한다. 나뿐만 아니다. 세상에는(적어도 내가 만난 엔지니어 중에는) 과학이나 수학의 세계를 공학과 혼동하는 사람도 있고 과학과 수학이 공학보다 더 우위에 있다고 말하는 사람도 있다. 모두 공학을 잘 이해하지 못해 일어나는 일이다.</p><p>공학의 본질적 목표는 무엇이며, 엔지니어가 정확히 무슨 일을 하는 사람을 일컫는지 알지 못하면서 소프트웨어 공학 관련 직업에 종사하고 있다는 사실이 아이러니하게 느껴지기도 한다. 그래서 그런지 요샌 스킬-업보단 공학이란 무엇인가에 좀 더 관심을 두고 「<a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791185628141&orderClick=LAG&Kc=">공학 학교에서 배운 101가지</a>」나 「<a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9788925559315&orderClick=LAG&Kc=http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9788925559315&orderClick=LAG&Kc=">맨발의 엔지니어들</a>」 같은 조금은 덜 전문적이지만 딱딱하지 않은 책을 읽는데 시간을 내고 있다.</p><p>이번에(사실 포스팅으로는 처음) 소개할 책은 「<a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9788959090112&orderClick=LAH&Kc=">공학기술과 사회</a>」다. 공학에 대한 여러 가지 잡생각을 하며 퇴근하던 중 강남 <a href="http://www.ypbooks.co.kr/m_main.yp">영풍문고</a>에 들르게 됐는데, 진열장에 꽂혀 있는 이 책이 나의 눈길을 사로잡았다.</p>    <figure title="공학 기술과 사회 책표지">      <a href="/images/read-the-engineering-technology-and-society/engineering.01.jpg" target="_blank">        <img           src="/images/read-the-engineering-technology-and-society/engineering.01.jpg"           alt="공학 기술과 사회 책표지"           style=""        >      </a>      <figcaption>&lt;그림 1. 공학 기술과 사회&gt;</figcaption>    </figure>  <p>책 표지나 내용 전개 방식을 보면 다소 대학 교재 같은 느낌이 난다. 실제로 한국공학교육센터에서 공학소양 교과목 DB구축사업의 목적으로 연구비를 받아 집필됐다고 한다. 교재 같은 점만 제외하면 책 내용 자체는 제법 훌륭한 편이다. </p><blockquote><p>엔지니어가 전공을 통하여 사회에 공헌하기 위해서는 자기가 하는 일이 사회와 어떤 관계가 있으며, 기술이 전반적으로 사회와 서로 어떤 영향을 주고 받는지 이해할 필요가 있다.</p></blockquote><p>소프트웨어 엔지니어는 현재에 집중하여 좀 더 나은 미래를 만들기 위해 살아가지만, 사회에 있어 의미 있는 무엇인가를 만들기 위해선 사회와 기술의 관계를 이해할 필요가 있다. 눈앞에 놓여있는 기술적 문제 해결에만 집중하기보단 조금 더 넓은 시야를 가지고 다양한 사회적 문제를 어떻게 해결할 수 있을지, 사회 속에 엔지니어와 기술의 책임은 무엇일지 고민해야만 엔지니어로서 가장 만족할 수 있는 성과를 달성할 수 있지 않을까.</p><p>이때 이 책이 그러한 시작점으로써 좋은 지적 재료가 될 수 있다. 공학의 정의부터 엔지니어적 가치, 기술의 역사, 기술결정론이나 기술 사회적 구성론 같은 기술사회론도 일반인이 이해하고 받아드리기 쉽게 작성돼 있다. </p><p>앞으로도 공학의 본질적인 측면과 사회와의 관계를 이해하고 엔지니어로서의 책임 범위와 중요한 덕목을 갖춘 그런 훌륭한 엔지니어가 되기 위해 끊임없이 정진해야 할 것 같다. 먼 훗날 한 사람의 엔지니어로서 훌륭한 인생을 살았다고 스스로 자신 있게 말할 수 있도록 말이다.</p><p>그나저나 모두 베이컨을 아는가? 먹는 베이컨이 아니라 “아는 것이 힘이다”라고 말한 철학자 <a href="https://namu.wiki/w/%ED%94%84%EB%9E%9C%EC%8B%9C%EC%8A%A4%20%EB%B2%A0%EC%9D%B4%EC%BB%A8">프랜시스 베이컨(Francis Bacon)</a> 말이다(최근에 FRP 라이브러리로도 등장했다 -<a href="http://baconjs.github.io/">Bacon.js</a>-). 이 책을 통해서 알게 된 사실인데 베이컨은 공학적 측면에서도 상당히 멋진 분인 걸 알 수 있었다.</p><blockquote><p>근데 초 서양에서 기술의 가치를 높게 평가하고 기술 진보를 인류의 역사에서 매우 중요한 과제로 제시함으로써 플라톤과 아리스토텔레스 이후 지속돼왔던 “기술에 대한 천대”를 종식시키려 노력했던 대표적 인물이 바로 프랜시스 베이컨(Francis Bacon)이다. … 중략 … 베이컨은 발명을 통한 기술적 진보가 사회 발전에 필수적인 요소임을 강조함으로서 과학은 고상하지만 기술은 비천하다는 편견을 없애려 했다.</p></blockquote><p>우리 모두 자부심을 가지고 유용한 제품을 만들어내는 훌륭한 공학자의 인생을 살아나가자. 기술은 절대 천하지 않고 공학은 위대하다! 끝.</p>]]></content>
    
    
    <summary type="html">지호출판사에서 발행한 「공학기술과 사회」라는 책을 읽고 개인적인 느낌과 감평을 작성한 문서입니다.</summary>
    
    
    
    <category term="Book" scheme="http://blog.coderifleman.com/categories/Book/"/>
    
    
    <category term="Engineering" scheme="http://blog.coderifleman.com/tags/Engineering/"/>
    
    <category term="Technology" scheme="http://blog.coderifleman.com/tags/Technology/"/>
    
    <category term="Society" scheme="http://blog.coderifleman.com/tags/Society/"/>
    
    <category term="Review" scheme="http://blog.coderifleman.com/tags/Review/"/>
    
  </entry>
  
  <entry>
    <title>E2E 테스트와 나이트왓치</title>
    <link href="http://blog.coderifleman.com/2016/06/17/e2e-test-and-nightwatch/"/>
    <id>http://blog.coderifleman.com/2016/06/17/e2e-test-and-nightwatch/</id>
    <published>2016-06-16T15:00:00.000Z</published>
    <updated>2022-11-09T05:45:21.010Z</updated>
    
    <content type="html"><![CDATA[<p>나이트왓치를 소개하기 전에 E2E 테스트의 정의부터 셀레니움 웹드라이버 등 기본 개념부터 간단히 소개하겠다.</p><h2 id="E2E-테스트"><a href="#E2E-테스트" class="headerlink" title="E2E 테스트"></a>E2E 테스트</h2><h3 id="정의"><a href="#정의" class="headerlink" title="정의"></a>정의</h3><p>소프트웨어 테스트는 <a href="https://en.wikipedia.org/wiki/Software_testing##Testing_levels">테스트의 규모(레벨)</a>에 따라 유닛 테스트, 통합 테스트, 시스템 테스트, 인수 테스트 이렇게 4가지로 분류한다. 여기에서 E2E 테스트는 시스템 테스트에 속한다. </p><p>E2E(End-to-End) 테스트는 전체 시스템이 제대로 작동하는지 확인 하기 위한 테스트로 시나리오 테스트, 기능 테스트, 통합 테스트, GUI 테스트를 하는데 사용한다. API와의 연동도 테스트 항목에 포함되기 때문에 일반적으로 목(Mock)이나 스텁(Stub)과 같은 테스트 더블을 사용하지 않으며 최대한 실제 시스템을 사용하는 사용자 관점에서 시뮬레이션 한다. 그래서 테스트 속도가 서비스 규모에 따라 상당히 느릴 수 있기 때문에 유닛 테스트나 기능 테스트를 위한 일반적인 테스트 자동화와 시스템 테스트를 위한 E2E 테스트 자동화를 함께 구성한다.</p><h3 id="E2E-테스트-프레임워크"><a href="#E2E-테스트-프레임워크" class="headerlink" title="E2E 테스트 프레임워크"></a>E2E 테스트 프레임워크</h3><p>E2E 테스트 프레임워크는 다양한 종류가 있는데, 크게 헤드리스 브라우저를 의존하는 것과 셀레니움 웹드라이버를 의존하는 것으로 나눌 수 있다. 셀레니움 웹드라이버는 다음 절에서 자세히 설명한다.</p><p>헤드리스 브라우저는 커맨드 라인 명령어로 조작할 수 있는 화면이 없는 브라우저로 Jsdom 기반의 좀비(Zombie.js), 웹킷 엔진 기반의 팬텀(Pantom.js), 겟코 엔진 기반의 슬리머(Slimer.js) 등이 있다. 잘 알려진 캐스퍼(Casper.js)는 팬텀과 슬리머를 조금 더 사용하기 쉽게 만들어 놓은 유틸리티 도구다. 헤드리스 브라우저는 기본적으로 크로스 브라우징 테스트가 불가능하며 어썰트(Assert)도 내장하고 있지 않기 때문에 필요하다면 추가를 해야한다.</p><p>셀레니움 웹드라이버를 의존하는 프레임워크로는 <a href="http://webdriver.io/">webdriver.io</a>, <a href="https://github.com/cucumber/cucumber-js">큐컴버(Cucumber.js)</a>, <a href="https://github.com/angular/protractor">프로트랙터</a>, <a href="http://nightwatchjs.org/">나이트왓치</a> 등이 있다. 이들은 크로스 브라우징 테스트가 가능하고 어썰트도 내장하고 있다. 단, 각 프레임워크 마다 내장하고 있는 어썰트 라이브러리는 다르다.</p><h3 id="셀레니움-웹드라이버"><a href="#셀레니움-웹드라이버" class="headerlink" title="셀레니움 웹드라이버"></a>셀레니움 웹드라이버</h3><p>나이트왓치는 셀레니움 웹드라이버(Selenium WebDriver) API를 사용해 개발된 E2E 테스트 프레임워크이기 때문에 본격적으로 사용해보기 전에 셀레니움과 웹드라이버를 먼저 이해할 필요가 있다.</p><p>셀레니움 웹드라이버의 원래 이름은 셀레니움(또는 셀레니움 1.0)이었다. 셀레니움은 웹 브라우저를 사용하여 웹 애플리케이션을 테스트하는 오픈 소스 도구다. 이때 사람의 손으로 직접 웹 브라우저를 조작하는 것이 아니라 작성된 스크립트에 따라 자동으로 조작한다. 이러한 방법을 브라우저 자동화(Browser Automation)라고 표현한다.</p><p>셀레니움은 시카고에 위치한 <a href="https://www.thoughtworks.com/">소트워크스(ThoughtWorks)</a> 사에서 개발을 시작했다. 소트워크스는 마틴 파울러(Martin Fowler)가 속한 그룹으로 유명하다.</p><p>웹드라이버는 셀레니움의 단점을 보완하고자 구글의 엔지니어들이 개발하고 사용한 브라우저 자동 테스트 도구이다. 2006년 경 구글에서 근무 중이던 <a href="https://www.linkedin.com/in/sistewart">시몬 스튜어트(Simon Stewart)</a>가 주도해 프로젝트를 시작하고 2009년에 처음으로 공식 발표했다.</p>    <figure title="Selenium Projects">      <a href="/images/e2e-test-and-nightwatch/e2e_and_nightwatch.01.png" target="_blank">        <img           src="/images/e2e-test-and-nightwatch/e2e_and_nightwatch.01.png"           alt="Selenium Projects"           style=""        >      </a>      <figcaption>&lt;그림 1. 셀레니움 프로젝트의 흐름&gt;</figcaption>    </figure>  <p>과거 셀레니움은 자체 엔진인 셀레니움 RC(Remote Control)를 이용해 브라우저와 통신했다.</p><p>셀레니움 RC는 자바나 파이썬 등의 언어로 스크립트를 작성하면 그 스크립트를 기반으로 브라우저를 조작하는 자바스크립트를 생성하고 해당 페이지에 삽입 후 브라우저를 조작하는 간단한 구조였다. 이러한 구조는 브라우저의 보안 제약이나 자바스크립트의 한계로 인해 실효성이 떨어지는 단점이 있었다. 이 단점이 시몬 스튜어트가 웹드라이버를 만들게 된 이유이기도 하다.</p><p>그에 반해 웹드라이버는 브라우저의 확장 기능과 OS의 기본 기능 등을 이용하여 브라우저를 조작하는 구조였다. 이는 셀레니움 RC의 단점을 충족해줄 수 있는 방식이었다.</p>    <figure title="Selenium webdriver high level block diagram">      <a href="/images/e2e-test-and-nightwatch/e2e_and_nightwatch.02.png" target="_blank">        <img           src="/images/e2e-test-and-nightwatch/e2e_and_nightwatch.02.png"           alt="Selenium webdriver high level block diagram"           style=""        >      </a>      <figcaption>&lt;그림 1. 셀레니움 웹드라이버 다이어그램&gt;</figcaption>    </figure>  <p>이 방식이 성공하여 셀레니움 RC와 웹드라이버 통합이 이루어졌고 2011년 7월에 셀레니움 웹드라이버(또는 셀레니움 2.0)를 릴리즈하게 된다. 즉, 현재 우리가 알고있는 셀레니움은 웹드라이버와 통합한 버전이다.</p><p>그림 2를 보면 알 수 있듯이 웹드라이버는 다양한 브라우저와 환경을 대응해야하는데, 브라우저마다 이를 위한 API가 다를 경우 또 다른 문제가 발생할 수 있기 때문에 현재 표준화를 제정(<a href="https://www.w3.org/TR/webdriver/">W3C WebDriver</a>) 중이다.</p><p>현재 셀레니움 웹드라이버는 파이썬, 루비, 자바, C## 그리고 Node.js를 이용해 웹브라우저는 조작할 수 있도록 다양한 API를 제공하고 있다. 하지만 셀레니움 서버와 자바스크립트의 궁합이 좋지 않고, 돔을 조작 하거나 셀렉팅하는데 한계가 있어 셀레니움 웹드라이버와 노드를 바인딩하여 다양한 기능을 제공하는 여러가지 형태의 프로젝트가 생겨났다. 그 중 유명한 프로젝트가 바로 webdriver.io와 나이트왓치 그리고 앵귤러 프로젝트를 위한 프로트랙터다.</p><p>이들 도구는 웹드라이버 API를 사용할 때 생기는 다양한 패턴을 추상화한 API와 신택스 슈가 등을 제공해 셀레니움 2.0 보더 더 편리하고 다양한 경험을 제공한다.</p><h2 id="나이트왓치"><a href="#나이트왓치" class="headerlink" title="나이트왓치"></a>나이트왓치</h2><p>나이트왓치는 노드 기반의 E2E 테스트 프레임워크다. 셀레니움 웹드라이버를 중개하여 각종 브라우저를 조작하고 동작이 기대한 것과 일치하는지 테스트하는데 사용한다. CSS 셀렉터로 엘리먼트를 셀렉팅하여 테스트를 작성할 수 있도록 하는 기능과 신텍스 슈가 그리고 단순하고 간결한 문법을 제공한다. 또한 테스트 러너를 포함하고 있으므로 독자적으로 그룹화한 테스트를 한번에 실행할 수 있으며 지속적인 통합의 파이프 라인과 합칠 수 있다는 특징을 가지고 있다.</p><p>나이트왓치를 알게 된건 나보다 먼저 E2E 테스트를 리서치하고 관련 도구를 찾고있던 훈민이형(개발왕 김코딩, <a href="http://huns.me/">블로그</a>) 덕분이었다. 미리 삽질을 하고 계셨기 때문에 다른 도구를 선택하기 보다 같이 삽질하는 편이 고민할 시간도 적어서 큰 고민 없이 사용했다.</p><h3 id="설치하기"><a href="#설치하기" class="headerlink" title="설치하기"></a>설치하기</h3><p>나이트왓치 설치는 개발자 가이드 <a href="http://nightwatchjs.org/guide##installation">Getting Started</a> 절에 잘 설명돼 있다. 이 문서에는 간단하게 요약해 설치 과정을 설명한다. 우선 NPM을 이용해 설치한다.</p><pre class="language-base" data-language="base"><code class="language-base">$ npm install --save-dev nightwatch</code></pre><p>웹드라이버로 브라우저와 통신하기 위해서는 셀레니움 서버를 실행시켜야한다. <a href="http://selenium-release.storage.googleapis.com/index.html">셀레니움 서버 다운로드 사이트</a>에서 파일을 다운 받고 아래와 같이 서버를 실행한다. 이 글을 작성하는 현재 기준 가장 최신 버전은 2.53.0 이다.</p><p>프로젝트 디렉터리에서 nightwatch.json을 생성하고 다음과 같이 작성한다. 옵션의 자세한 설명은 개발자 가이드 <a href="http://nightwatchjs.org/guide##settings-file">Configuration</a> 절을 참고한다.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token punctuation">&#123;</span>  <span class="token string">"src_folders"</span> <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"tests"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 테스트할 디렉터리, 배열로 지정</span>  <span class="token string">"output_folder"</span> <span class="token operator">:</span> <span class="token string">"tests/reports"</span><span class="token punctuation">,</span> <span class="token comment">// JUnit XML 리포트 파일이 저장될 위치</span>  <span class="token string">"custom_commands_path"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">// 불러올 커스텀 커맨드가 있는 위치</span>  <span class="token string">"custom_assertions_path"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">// 불러올 커스텀 어썰트가 있는 위치</span>  <span class="token string">"page_objects_path"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">// 불러올 페이지 객체가 있는 위치</span>  <span class="token string">"globals_path"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">// 불러올 외부 글로벌 모듈이 있는 위치</span>  <span class="token string">"selenium"</span> <span class="token operator">:</span> <span class="token punctuation">&#123;</span>   <span class="token comment">// 셀레니움 서버 환경 설정</span>    <span class="token string">"start_process"</span> <span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 테스트 시작시 셀레니움 프로세스를 자동으로 실행할 것 인지 여부</span>    <span class="token string">"server_path"</span> <span class="token operator">:</span> <span class="token string">"./selenium-server-standalone-2.53.0.jar"</span><span class="token punctuation">,</span> <span class="token comment">// 셀레니움 서버 jar 파일의 경로, start_process가 false면 지정하지 않아도 된다.</span>    <span class="token string">"log_path"</span> <span class="token operator">:</span> <span class="token string">"tests/logs"</span><span class="token punctuation">,</span> <span class="token comment">// 셀레니움의 output.log 파일이 저장될 경로</span>    <span class="token string">"host"</span> <span class="token operator">:</span> <span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token comment">// 셀레니움 서버의 listen ip</span>    <span class="token string">"port"</span> <span class="token operator">:</span> <span class="token number">4444</span><span class="token punctuation">,</span> <span class="token comment">// 셀레니움 서버의 listen port</span>    <span class="token string">"cli_args"</span> <span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 셀레니움 프로세스로 넘겨질 cli 인자 목록</span>      <span class="token string">"webdriver.chrome.driver"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>      <span class="token string">"webdriver.ie.driver"</span> <span class="token operator">:</span> <span class="token string">""</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token string">"test_settings"</span> <span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 테스트 브라우저 별 환경 설정</span>    <span class="token string">"default"</span> <span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 모든 브라우저에 적용 될 공통 설정</span>      <span class="token string">"launch_url"</span> <span class="token operator">:</span> <span class="token string">"http://localhost"</span><span class="token punctuation">,</span>      <span class="token string">"selenium_port"</span>  <span class="token operator">:</span> <span class="token number">4444</span><span class="token punctuation">,</span>      <span class="token string">"selenium_host"</span>  <span class="token operator">:</span> <span class="token string">"localhost"</span><span class="token punctuation">,</span>      <span class="token string">"silent"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 셀레니움의 로그를 숨길지 여부</span>      <span class="token string">"screenshots"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 테스트가 실패 했을 때 촬영 될 스크린샷 설정</span>        <span class="token string">"enabled"</span> <span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token string">"on_failure"</span> <span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token string">"on_error"</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        <span class="token string">"path"</span> <span class="token operator">:</span> <span class="token string">"tests/screenshots"</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token string">"desiredCapabilities"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 셀레니움 웹드라이버로 전달할 브라우저 이름과 기능 지정</span>        <span class="token string">"browserName"</span><span class="token operator">:</span> <span class="token string">"firefox"</span><span class="token punctuation">,</span>        <span class="token string">"javascriptEnabled"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token string">"acceptSslCerts"</span><span class="token operator">:</span> <span class="token boolean">true</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>tests 디렉터리 하위에 demo.js를 생성하고 간단한 테스트 코드를 한다.</p><pre class="language-js" data-language="js"><code class="language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">'사용자는 검색어를 입력 후 검색어가 포함된 자동 완성 리스트를 볼 수 있다.'</span> <span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">browser</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        browser            <span class="token punctuation">.</span><span class="token function">url</span><span class="token punctuation">(</span><span class="token string">'http://www.google.com'</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">waitForElementVisible</span><span class="token punctuation">(</span><span class="token string">'body'</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span><span class="token string">'input[type=text]'</span><span class="token punctuation">,</span> <span class="token string">'nightwatch'</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">pause</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span>assert<span class="token punctuation">.</span><span class="token function">containsText</span><span class="token punctuation">(</span><span class="token string">'##sbtc'</span><span class="token punctuation">,</span> <span class="token string">'nightwatch'</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>이어서 아래 명령어로 간단한 E2E 테스트를 실행할 수 있다.</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ ./node_modules/nightwatch/bin/nightwatch</code></pre><p>하지만 현재 파이어폭스 버전 47에 문제가 있어 테스트가 실행되지 않을것이다. 파이어폭스에서 테스트 하고 싶다면 예전 버전(<a href="https://support.mozilla.org/en-US/kb/install-older-version-of-firefox">Install an older version of Firefox</a>)으로 다운그레이드 하거나 GeckoDriver를 사용해야한다(<a href="https://developer.mozilla.org/en-US/docs/Mozilla/QA/Marionette/WebDriver##Setting_up_the_Marionette_executable">Setting up the Marionette executable</a>). 여기에서는 GeckoDriver를 이용하는 방법을 소개(OSX 기준)하겠다.</p><p>먼저 <a href="https://github.com/mozilla/geckodriver/releases">mozilla/geckodriver</a>에서  GeckoDriver를 다운로드한다.</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> ~/Downloads$ <span class="token function">wget</span> https://github.com/mozilla/geckodriver/releases/download/v0.8.0/geckodriver-0.8.0-OSX.gz</code></pre><p>다운로드한 파일을 압축 해제하고 적당한 위치로 옮긴 후 실행가능한 파일로 변경한다.</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ gunzip geckodriver-0.8.0-OSX.gz$ <span class="token function">mkdir</span> executable <span class="token operator">&amp;&amp;</span> <span class="token function">mv</span> geckodriver-0.8.0-OSX executable/wires$ <span class="token function">chmod</span> <span class="token number">755</span> executable/wires</code></pre><p>이제 .bash_profile(또는 .zshrc)에서 PATH를 지정한다.</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">vim</span> ~/.zshrc<span class="token assign-left variable">GECKO_DRIVER</span><span class="token operator">=</span><span class="token environment constant">$HOME</span>/Downloads/executable<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$HOME</span>/bin:/usr/local/bin:/usr/local/sbin:<span class="token variable">$GECKO_DRIVER</span><span class="token builtin class-name">:</span><span class="token environment constant">$PATH</span><span class="token comment">## rc파일을 다시 불러온다.</span>$ <span class="token builtin class-name">source</span> ~/.zshrc</code></pre><p>마지막으로 nightwatch.json파일에서 desiredCapabilities 속성을 다음과 같이 변경한다.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token string">"desiredCapabilities"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>  <span class="token string">"browserName"</span><span class="token operator">:</span> <span class="token string">"firefox"</span><span class="token punctuation">,</span>  <span class="token string">"marionette"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 추가</span>  <span class="token string">"javascriptEnabled"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token string">"acceptSslCerts"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span></code></pre><p>이제 다시 실행해보면 파이어폭스 브라우저에서 정상적으로 테스트가 진행될 것이다.</p>    <figure title="데모 테스트 실행 결과">      <a href="/images/e2e-test-and-nightwatch/e2e_and_nightwatch.03.png" target="_blank">        <img           src="/images/e2e-test-and-nightwatch/e2e_and_nightwatch.03.png"           alt="데모 테스트 실행 결과"           style=""        >      </a>      <figcaption>&lt;그림 3. 데모 테스트 실행 결과&gt;</figcaption>    </figure>  <h3 id="여러-브라우저에서-동시에-테스트하기"><a href="#여러-브라우저에서-동시에-테스트하기" class="headerlink" title="여러 브라우저에서 동시에 테스트하기"></a>여러 브라우저에서 동시에 테스트하기</h3><p>현재 작성한 설정 파일로 나이트왓치를 실행하면 파이어폭스에서만 테스트가 진행된다. 이번엔 크롬 브라우저에서도 테스트가 진행되도록 설정을 변경하겠다. 크롬 브라우저는 셀레니움과 통신할 웹드라이버를 별도로 설치해야하는데 웹드라이버 매니저를 사용하면 쉽게 설치할 수 있다. 아래 명령어로 웹드라이버 매니저를 설치한다.</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> --save-dev webdriver-manager <span class="token comment"># 크롬 웹드라이버와 앞 절에서 다운로드 받았던 셀레니움 서버가 함께 설치된다.</span>$ ./node_modules/.bin/webdriver-manager update <span class="token comment"># 또는 아래 명령어 처럼 인자를 전달해 별도로 설치할 수도 있다.</span><span class="token comment"># ./node_modules/.bin/webdriver-manager update --chrome</span></code></pre><p>이제 nightwatch.json에 셀레니움 서버 경로와 크롬 웹드라이버 서버 경로를 수정한다.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token string">"selenium"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>  <span class="token string">"start_process"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token string">"server_path"</span><span class="token operator">:</span> <span class="token string">"./selenium-server-standalone-2.53.0.jar"</span><span class="token punctuation">,</span>  <span class="token string">"log_path"</span><span class="token operator">:</span> <span class="token string">"tests/logs"</span><span class="token punctuation">,</span>  <span class="token string">"host"</span><span class="token operator">:</span> <span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span>  <span class="token string">"port"</span><span class="token operator">:</span> <span class="token number">4444</span><span class="token punctuation">,</span>  <span class="token string">"cli_args"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token string">"webdriver.chrome.driver"</span> <span class="token operator">:</span> <span class="token string">"node_modules/webdriver-manager/selenium/chromedriver_2.21"</span><span class="token punctuation">,</span> <span class="token comment">// 추가</span>    <span class="token string">"webdriver.ie.driver"</span><span class="token operator">:</span> <span class="token string">""</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span></code></pre><p>다음으로 default 속성에 작성했던 파이어폭스 브라우저 설정을 test_settings 속성 하위로 옮기고 크롬 브라우저 설정도 함께 추가 작성한다.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token punctuation">&#123;</span>  <span class="token comment">// ... 생략 ...</span>  <span class="token string">"test_settings"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token string">"default"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token string">"launch_url"</span><span class="token operator">:</span> <span class="token string">"http://localhost"</span><span class="token punctuation">,</span>      <span class="token string">"selenium_port"</span><span class="token operator">:</span> <span class="token number">4444</span><span class="token punctuation">,</span>      <span class="token string">"selenium_host"</span><span class="token operator">:</span> <span class="token string">"localhost"</span><span class="token punctuation">,</span>      <span class="token string">"silent"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>      <span class="token string">"screenshots"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token string">"enabled"</span> <span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token string">"on_failure"</span> <span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token string">"on_error"</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        <span class="token string">"path"</span> <span class="token operator">:</span> <span class="token string">"tests/screenshots"</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token string">"firefox"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token string">"desiredCapabilities"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token string">"browserName"</span><span class="token operator">:</span> <span class="token string">"firefox"</span><span class="token punctuation">,</span>        <span class="token string">"marionette"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token string">"javascriptEnabled"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token string">"acceptSslCerts"</span><span class="token operator">:</span> <span class="token boolean">true</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token string">"chrome"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token string">"desiredCapabilities"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token string">"browserName"</span><span class="token operator">:</span> <span class="token string">"chrome"</span><span class="token punctuation">,</span>        <span class="token string">"javascriptEnabled"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token string">"acceptSslCerts"</span><span class="token operator">:</span> <span class="token boolean">true</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>이제 아래 명령어로 실행하면 두 브라우저에서 동시에 테스트가 실행된다.</p><pre class="language-base" data-language="base"><code class="language-base">$ .&#x2F;node_modules&#x2F;nightwatch&#x2F;bin&#x2F;nightwatch --env firefox,chrome</code></pre><p>사파리 브라우저에서 테스트하고자 한다면 사파리 웹드라이버를 확장 기능으로 설치해야한다. 자세한 내용은 나이트왓치 위치의 <a href="https://github.com/nightwatchjs/nightwatch/wiki/Running-tests-in-Safari">Running tests in Safari</a> 문서를 참고한다.</p>    <figure title="사파리의 웹드라이버 확장프로그램">      <a href="/images/e2e-test-and-nightwatch/e2e_and_nightwatch.04.png" target="_blank">        <img           src="/images/e2e-test-and-nightwatch/e2e_and_nightwatch.04.png"           alt="사파리의 웹드라이버 확장프로그램"           style=""        >      </a>      <figcaption>&lt;그림 4. 사파리의 웹드라이버 확장프로그램&gt;</figcaption>    </figure>  <h3 id="모카-사용하기"><a href="#모카-사용하기" class="headerlink" title="모카 사용하기"></a>모카 사용하기</h3><p>이번엔 테스트 코드를 모카 기반으로 작성할 수 있는 환경을 만들어보겠다. 나이트왓치는 어썰트로 챠이(chai)를 내장하고 있지만 모카는 별도로 설정해 사용해야한다. 모카를 설정하는 자세한 내용은 개발자 가이드 <a href="http://nightwatchjs.org/guide##using-mocha">Using Mocha</a> 절을 참고한다. 모카를 굳이 사용하려는 이유는 JUnit XML로 리포팅 하는 기본 러너와는 달리 다양하고 보기 쉬운 리포팅을 지원하기 때문이다.</p><p>먼저 nightwatch.json 파일에 다음과 같이 test_runner 속성을 추가한다. 옵션에 관한 자세한 설명은 모카 위키의 <a href="https://github.com/mochajs/mocha/wiki/Using-mocha-programmatically##set-options">Set options</a> 절을 참고한다.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token punctuation">&#123;</span>  <span class="token string">"test_runner"</span> <span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token string">"type"</span> <span class="token operator">:</span> <span class="token string">"mocha"</span><span class="token punctuation">,</span>    <span class="token string">"options"</span> <span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token string">"ui"</span><span class="token operator">:</span> <span class="token string">"bdd"</span><span class="token punctuation">,</span>      <span class="token string">"reporter"</span><span class="token operator">:</span> <span class="token string">"spec"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token comment">// ... 생략 ...</span><span class="token punctuation">&#125;</span></code></pre><p>테스트 코드를 모카 기반으로 재작성한다.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">'구글 메인 페이지'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token function">before</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">client<span class="token punctuation">,</span> done</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">after</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">client<span class="token punctuation">,</span> done</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">'##사용자는 검색할 수 있다.'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">'사용자는 검색어를 입력 후 자동 완성된 리스트를 볼 수 있다.'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">client<span class="token punctuation">,</span> done</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            client                <span class="token punctuation">.</span><span class="token function">url</span><span class="token punctuation">(</span><span class="token string">'http://www.google.com'</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">waitForElementVisible</span><span class="token punctuation">(</span><span class="token string">'body'</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span><span class="token string">'input[type=text]'</span><span class="token punctuation">,</span> <span class="token string">'nightwatch'</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">pause</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span>assert<span class="token punctuation">.</span><span class="token function">containsText</span><span class="token punctuation">(</span><span class="token string">'##sbtc'</span><span class="token punctuation">,</span> <span class="token string">'nightwatch'</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>done<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>다시 실행해 보면 모카 기반으로 테스트 코드가 동작하는 것을 볼 수 있다.</p>    <figure title="모카 테스트 실행 결과">      <a href="/images/e2e-test-and-nightwatch/e2e_and_nightwatch.05.png" target="_blank">        <img           src="/images/e2e-test-and-nightwatch/e2e_and_nightwatch.05.png"           alt="모카 테스트 실행 결과"           style=""        >      </a>      <figcaption>&lt;그림 5. 모카 테스트 실행 결과&gt;</figcaption>    </figure>  <h3 id="브라우저-스택"><a href="#브라우저-스택" class="headerlink" title="브라우저 스택"></a>브라우저 스택</h3><p>크로스 브라우징 테스트를 할 수 있도록 해주는 웹 서비스인 브라우저 스택은 다양한 플랫폼과 웹 브라우저를 지원한다. 또한, 셀레니움 서버도 제공하고 있는데 이를 이용하면 나이트왓치와 연동해 테스트를 자동화할 수 있다.</p><p>먼저 browserstack.json 파일을 작성한다.</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token punctuation">&#123;</span>  <span class="token comment">// ... 생략 ...</span>  <span class="token string">"selenium"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token string">"start_process"</span><span class="token operator">:</span> <span class="token boolean">false</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token string">"test_settings"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token string">"default"</span> <span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token string">"launch_url"</span> <span class="token operator">:</span> <span class="token string">"http://hub.browserstack.com"</span><span class="token punctuation">,</span>      <span class="token string">"selenium_host"</span> <span class="token operator">:</span> <span class="token string">"hub.browserstack.com"</span><span class="token punctuation">,</span>      <span class="token string">"selenium_port"</span> <span class="token operator">:</span> <span class="token number">80</span><span class="token punctuation">,</span>      <span class="token string">"silent"</span> <span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>      <span class="token string">"screenshots"</span> <span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token string">"enabled"</span> <span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token string">"on_failure"</span> <span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token string">"on_error"</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        <span class="token string">"path"</span> <span class="token operator">:</span> <span class="token string">"tests/screenshots"</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token string">"desiredCapabilities"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token string">"platform"</span><span class="token operator">:</span> <span class="token string">"xp"</span><span class="token punctuation">,</span>        <span class="token string">"browserName"</span><span class="token operator">:</span> <span class="token string">"firefox"</span><span class="token punctuation">,</span>        <span class="token string">"javascriptEnabled"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token string">"acceptSslCerts"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token string">"browserstack.user"</span> <span class="token operator">:</span> <span class="token string">"user_id"</span><span class="token punctuation">,</span> <span class="token comment">// 브라우저 스택 아이디</span>        <span class="token string">"browserstack.key"</span> <span class="token operator">:</span> <span class="token string">"user_key"</span> <span class="token comment">// 브라우저 스택 키</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>platform 속성엔 XP를 browserName 속성엔 파이어폭스를 지정했고 로컬 환경에서 셀레니움 서버를 실행시킬 필요가 없기 때문에 start_process은 false로 지정했다. 이제 브라우저 스택은 윈도우즈 XP 환경의 파이어폭스 브라우저에서 테스트를 진행할 것이다. 브라우저 스택에서 지원하는 플랫폼과 브라우저는 공식 홈페이지의 <a href="https://www.browserstack.com/automate/capabilities">Capabilities</a> 페이지를 참고하면 알 수 있다.</p><p>아래 명령어를 참고해 실행해본다.</p><pre class="language-js" data-language="js"><code class="language-js">$ <span class="token punctuation">.</span><span class="token operator">/</span>node_modules<span class="token operator">/</span>nightwatch<span class="token operator">/</span>bin<span class="token operator">/</span>nightwatch <span class="token operator">--</span>config browserstack<span class="token punctuation">.</span>json</code></pre><p>다양한 플랫폼과 브라우저에서 E2E 테스트를 할 수 있다는 점은 큰 장점이지만 통신이나 테스트를 구동하는 속도가 아주 느리다. 따라서 테스트 배치 혹은 정기 배포 전에만 사용하기 적합해 보인다.</p><h3 id="웹스톰-디버깅"><a href="#웹스톰-디버깅" class="headerlink" title="웹스톰 디버깅"></a>웹스톰 디버깅</h3><p>웹스톰에서 노드 디버깅 도구를 사용해 나이트왓치를 디버깅할 수 있다. 자세한 내용은 Debugging <a href="https://github.com/nightwatchjs/nightwatch/wiki/Debugging-Nightwatch-tests-in-WebStorm">Nightwatch tests in WebStorm</a>을 참고한다. 다만, 파이프라인 방식이다 보니 브레이크 포인트를 활용한 디버깅이 다소 무의미한 느낌은 있다.</p><h2 id="끝으로"><a href="#끝으로" class="headerlink" title="끝으로"></a>끝으로</h2><p>여기까지 다양한 사전 지식을 설명하고 나이트왓치에 관해서 이해해봤다. E2E 테스트 특성 상 프로젝트 저장소에 테스트를 작성하고 유지하기 보단 별도의 E2E 테스트 저장소를 만들어 테스트를 작성하고 유지하는게 더 효율적이지 않을까 생각한다. 또, 나이트왓치에는 <a href="http://nightwatchjs.org/guide##page-objects">페이지 오브젝트</a>, <a href="http://nightwatchjs.org/guide##extending">커스텀 커맨드</a> 등 테스트를 작성할 때 유용한 개념을 제공한다. 이 두 개념을 적절히 잘 사용하면 생각보다 더 관리하기 쉬운 테스트 코드를 작성할 수 있다. </p><p>위에서 진행한 설치 및 설정 과정은 <a href="https://github.com/UYEONG/hello-nightwatch">UYEONG/hello-nightwatch</a>에 올려놓았으니 참고하길 바란다.</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="http://docs.seleniumhq.org/about/history.jsp">http://docs.seleniumhq.org/about/history.jsp</a></li><li><a href="http://google-opensource.blogspot.kr/2009/05/introducing-webdriver.html">http://google-opensource.blogspot.kr/2009/05/introducing-webdriver.html</a></li><li><a href="http://www.infoq.com/news/2011/07/Selenium-2">http://www.infoq.com/news/2011/07/Selenium-2</a></li><li><a href="https://seleniumhq.wordpress.com/2011/07/08/selenium-2-0/">https://seleniumhq.wordpress.com/2011/07/08/selenium-2-0/</a></li><li><a href="http://www.slideshare.net/sethmcl/join-the-darkside-nightwatchjs">http://www.slideshare.net/sethmcl/join-the-darkside-nightwatchjs</a></li><li><a href="https://github.com/SeleniumHQ/selenium/issues/2110">https://github.com/SeleniumHQ/selenium/issues/2110</a></li><li><a href="http://blog.trident-qa.com/2013/05/so-many-seleniums">http://blog.trident-qa.com/2013/05/so-many-seleniums</a> (일본어)</li><li><a href="https://app.codegrid.net/entry/selenium-1">https://app.codegrid.net/entry/selenium-1</a> (일본어)</li><li><a href="http://pydiary.bitbucket.org/blog/html/2015/08/28/test.html">http://pydiary.bitbucket.org/blog/html/2015/08/28/test.html</a> (일본어)</li><li><a href="http://blog.mmmcorp.co.jp/blog/2015/09/24/use-nightwatch/">http://blog.mmmcorp.co.jp/blog/2015/09/24/use-nightwatch/</a> (일본어)</li><li><a href="http://www.infoq.com/jp/news/2014/03/nightwatch">http://www.infoq.com/jp/news/2014/03/nightwatch</a> (일본어)</li><li><a href="http://qiita.com/yssg/items/a054d67bc7c7fc39b276">http://qiita.com/yssg/items/a054d67bc7c7fc39b276</a> (일본어)</li></ul>]]></content>
    
    
    <summary type="html">E2E의 정의와 E2E 테스트 프레임워크의 역사 그리고 나이트왓치를 소개하며 설치하는 방법과 사용하는 방법까지 폭 넓게 설명합니다.</summary>
    
    
    
    <category term="JavaScript" scheme="http://blog.coderifleman.com/categories/JavaScript/"/>
    
    <category term="Test" scheme="http://blog.coderifleman.com/categories/JavaScript/Test/"/>
    
    
    <category term="Test" scheme="http://blog.coderifleman.com/tags/Test/"/>
    
    <category term="E2E" scheme="http://blog.coderifleman.com/tags/E2E/"/>
    
    <category term="E2E Test" scheme="http://blog.coderifleman.com/tags/E2E-Test/"/>
    
    <category term="Nightwatch" scheme="http://blog.coderifleman.com/tags/Nightwatch/"/>
    
  </entry>
  
  <entry>
    <title>React에 대한 여러가지 생각을 읽고</title>
    <link href="http://blog.coderifleman.com/2016/04/26/read-the-thinking-about-react/"/>
    <id>http://blog.coderifleman.com/2016/04/26/read-the-thinking-about-react/</id>
    <published>2016-04-25T15:00:00.000Z</published>
    <updated>2022-11-09T05:45:21.014Z</updated>
    
    <content type="html"><![CDATA[<p>「<a href="http://youngrok.com/React%EC%97%90%20%EB%8C%80%ED%95%9C%20%EC%97%AC%EB%9F%AC%20%EA%B0%80%EC%A7%80%20%EC%83%9D%EA%B0%81#_=_">React에 대한 여러 가지 생각</a>」이라는 글에 직접 코멘트를 달까 생각했지만, 쓰다 보니 글이 길어져서 포스팅한다. 해당 글과는 다른 개인적인 의견에 평소 이야기하고 싶었던 내용을 약간 첨부해 글을 작성했다.</p><p>개인적으로 느꼈던 리액트의 가장 큰 장점은 사고의 단순함을 끌어내는데 있다고 생각한다(물론 애플리케이션의 성격이나 상황에 따라 다르다). 성능는 부차적인 것으로 앵귤러1 보다 빠른 메커니즘을 제공하지만, 당연 순수 자바스크립트보단 느리다.</p><p>보통 자바스크립트 개발 시에는 일일이 변경을 검사해 해당하는 DOM을 가져와서 값을 대입해줘야 하는 번거로움(혹은 고통스러운)이 있다. 그래서 몇십 밀리세컨드는 신경쓰지 않고 처음부터 다시 그리는 방법을 택한 적도 있었지만 그것만으로 만족하긴 찜찜하다.</p><p>HTTP의 Stateless 성을 기반으로 개발된 웹 MVC 프레임워크를 사용할 때는 요청이 들어오면 요청에 맞는 HTML을 생성해 응답해주면 끝나는 단순한 구조이기 때문인데 이런 고통스러운 부분이 적었다. 이때의 단순함을 리액트로 개발할 때 느꼈다.</p><p>Stateless 하니 왠지 functional이라는 키워드도 떠오르는데 실제로 리액트에서 뷰는 어떤 값에 의해 생성되는 단순한 결과값(스냅샷)에 불과하다. 리액트의 가장 큰 장점은 여기에 있다고 생각한다. 이 부분이 불변, 단방향 데이터 플로우와 좋은 궁합을 보여주는 점이다. 실제로 React의 개발자인 Jordan Walke는 XHP와 함수형에서 영감을 받아 리액트를 개발했다(<a href="https://www.quora.com/How-was-the-idea-to-develop-React-conceived-and-how-many-people-worked-on-developing-it-and-implementing-it-at-Facebook">참고</a>). 위와 같이 단순한 구조는 함수형에서, JSX는 XHP에서 영감을 받은 듯하다.</p><p>JSX는 서술적으로 컴포넌트를 표현하는 데 좋은 표기법이라고 생각한다. UI의 구조를 표현하거나 각 컴포넌트를 조합하는 데는 명령형(Imperative)보다 선언형(Declarative)이 더 적합한 경우가 많다.</p><p>아래는 jQuery로 뷰 로직을 작성할 때 자주 보이는 형태다.</p><iframe width="100%" height="300" src="//jsfiddle.net/uyeong21c/b5L5f3t9/5/embedded/js,css,html,result" allowfullscreen="allowfullscreen" frameborder="0"></iframe><p>아래는 JSX로 표현했을 때의 모습이다.</p><iframe width="100%" height="300" src="//jsfiddle.net/uyeong21c/h9y8o7ez/5/embedded/js,css,html,result" allowfullscreen="allowfullscreen" frameborder="0"></iframe><p>개인적으로 느꼈던 JSX의 단점은 애니메이션 표현에 있다. UI의 구조를 표현하기엔 적합하지만, 애니메이션처럼 뭔가 동적인 효과를 표현하기엔 오히려 장황하고 정확히 어떤 요소에 애니메이션을 적용하는지 한 번에 파악하기 힘들었다.</p><pre class="language-jsx" data-language="jsx"><code class="language-jsx"><span class="token entity named-entity" title="&lt;">&amp;lt;</span>Animation fadeOut<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token boolean">true</span><span class="token punctuation">&#125;</span><span class="token operator">></span><span class="token entity named-entity" title="&lt;">&amp;lt;</span>Something<span class="token operator">></span><span class="token entity named-entity" title="&lt;">&amp;lt;</span>Item<span class="token operator">/</span><span class="token operator">></span><span class="token entity named-entity" title="&lt;">&amp;lt;</span>Item<span class="token operator">/</span><span class="token operator">></span><span class="token entity named-entity" title="&lt;">&amp;lt;</span><span class="token operator">/</span>Something<span class="token operator">></span><span class="token entity named-entity" title="&lt;">&amp;lt;</span><span class="token operator">/</span>Animation<span class="token operator">></span><span class="token comment">// or</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.somthing'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fadeOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>JSX의 또 다른 문제는 낯섦이다. 기존 템플릿 방식이 아닌 XML 스러운 표기법을 그대로 자바스크립트 내에 작성한다. 이러한 방식은 처음에 상당히 혼란스럽게 느껴질 수 있다. 여기에서 거부감을 느끼고, 싫어야해야만 하는 또 다른 이유를 찾아 나서는 경우도 있다. 낯섦이라는 거부감을 잠시 잊어야하는데 말 처럼 쉬운 일은 아니다. 이런 거부감은 나 역시 있었고, 눈에 익는데 시간이 걸렸다(원래 새로운 패러다임은 이해하고 받아들이기 힘든 법이다).</p><p>해당 글에선 &lt;hr&gt;이나 &lt;input&gt;과 같은 한 줄 요소(Single-line element)도 닫아줘야 하는 이유를 HTML 규칙을 구현하는 데 한계가 있기 때문이라 말했지만, JSX는 XML-Like 한 언어이기 때문에 HTML이라기보단 XHTML에 가깝다. 그렇게 보면 당연한 부분이라고 생각한다.</p>    <figure title="공식 홈페이지의 JSX 소개 글">      <a href="/images/read-the-thinking-about-react/about_react.01.png" target="_blank">        <img           src="/images/read-the-thinking-about-react/about_react.01.png"           alt="공식 홈페이지의 JSX 소개 글"           style=""        >      </a>      <figcaption>&lt;그림 1. 공식 홈페이지의 JSX 소개 글&gt;</figcaption>    </figure>  <p>또한, 여러 문맥에 걸쳐 가상 돔의 속도를 언급한다. 가상 돔의 속도를 <a href="https://github.com/trueadm/inferno">inferno</a>와 같이 개선하는 방법도 있었는데 흥미로웠다. 랜더링 시 해당 DOM이 정적 요소인지 동적 요소인지 판단해 정적 요소라면 Diff 단계에서 아예 빼버린다. 이처럼 앞으로도 가상 돔의 속도를 개선할 수 있는 여지가 충분히 남아있다고 판단할 수 있다.</p><p>네이버의 효과툰 뷰 같이 인터렉션이나 애니메이션이 복잡해 성능을 많이 신경 써야 하는 부분이라면 React의 대체재를 찾기보단 해당 부분만 순수 자바스크립트로 구현하고 <a href="https://github.com/kirjs/react-highcharts">react-hightchart</a> 처럼 리액트가 읽을 수 있도록 어댑터만 제공하는 게 낫다.</p>    <figure title="React Adapter">      <a href="/images/read-the-thinking-about-react/about_react.02.png" target="_blank">        <img           src="/images/read-the-thinking-about-react/about_react.02.png"           alt="React Adapter"           style=""        >      </a>      <figcaption>&lt;그림 2. React Adapter 다이어그램&gt;</figcaption>    </figure>  <p>하나의 라이브러리만으로 서비스 개발 전체를 보완하긴 힘들다. 리액트가 서비스 개발 전체에 정답이 돼 줄 것으로 생각해선 안된다. 그렇다고 특정 부분에 한계가 있다고 다시 전체를 보완할 만한 프레임워크를 찾는 것도 무리다.</p><p>React의 본질은 성능이 아니다. 장점은 개인마다 느끼는 바가 다르겠지만, 개인적으로는 성능이라는 것에 너무 집중할 필요는 없다고 생각한다. React의 철학이 무엇이고 어떤 고통을 해결해주며 또, 어떤 고통은 해결해주지 못하는지 잘 이해하여 프로젝트 성격과 팀의 역량 등을 고려해 시기적절하게 사용하면 된다.</p>]]></content>
    
    
    <summary type="html">Youngrok Pak님의 「React에 대한 여러 가지 생각」을 읽고 해당 글에 대한 개인적인 의견과 React에 관해 평소에 이야기하고 싶었던 내용을 함께 이야기합니다.</summary>
    
    
    
    <category term="JavaScript" scheme="http://blog.coderifleman.com/categories/JavaScript/"/>
    
    <category term="React" scheme="http://blog.coderifleman.com/categories/JavaScript/React/"/>
    
    
    <category term="JavaScript" scheme="http://blog.coderifleman.com/tags/JavaScript/"/>
    
    <category term="React" scheme="http://blog.coderifleman.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React와 불변객체</title>
    <link href="http://blog.coderifleman.com/2015/08/16/react-and-immutable/"/>
    <id>http://blog.coderifleman.com/2015/08/16/react-and-immutable/</id>
    <published>2015-08-15T15:00:00.000Z</published>
    <updated>2022-11-09T05:45:21.013Z</updated>
    
    <content type="html"><![CDATA[<p>이번에는 불변객체의 개념과 React에 그 개념을 적용했을 때 어떤 이점을 얻을 수 있는지 소개하고자 합니다.</p><h2 id="불변객체란"><a href="#불변객체란" class="headerlink" title="불변객체란?"></a>불변객체란?</h2><p>객체 지향 프로그래밍에 있어서 불변객체(Immutable object)는 생성 후 그 상태를 변경할 수 없는 객체를 말합니다. 불변객체의 반대말은 가변객체로 자바스크립트의 배열과 같이 객체 내에서 관리하는 값이나 상태를 변경할 수 있는 것을 말합니다.</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> greeting <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">'Hello World!!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>greeting<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'World'</span><span class="token punctuation">,</span> <span class="token string">'Gil-dong'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>greeting<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hello World!!</span></code></pre><p>위 예에서 <code>greeting</code> 변수에 문자열 객체를 생성해 대입했습니다. 그리고 문자열 객체의 <code>replace</code> 메서드를 이용해 ‘World’라는 문자열을 ‘Gil-dong’으로 변경했습니다. 하지만 여전히 <code>greeting</code>의 값은 ‘Hello World’ 입니다.</p><p><code>greeting</code>에 생성한 문자열 객체는 불변 객체이므로 객체 자신이 소유하거나 관리하는 값 또는 상태를 바꿀 수 없습니다. 따라서 <code>replace</code> 메서드는 새로운 상태를 가지는 또 다른 객체를 생성합니다.</p><p>변수에 값을 바꾸기 위해서는 아래 처럼 새로운 객체를 변수에 대입해야 합니다.</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> greeting <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">'Hello World!!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>greeting <span class="token operator">=</span> greeting<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'World'</span><span class="token punctuation">,</span> <span class="token string">'Gil-dong'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>greeting<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hello Gil-dong!!</span></code></pre><h3 id="값-객체"><a href="#값-객체" class="headerlink" title="값 객체"></a>값 객체</h3><p>이러한 불변 객체의 특성은 우리가 밀접히 사용하는 <code>Number</code>, <code>String</code>, <code>Boolean</code>과 같은 값 객체에서 만날 수 있습니다. 값 객체란 비교 연산 시 자신의 상태보다 값(value)을 우선하는 단순한 객체를 말합니다.</p>    <div class="alert alert--info">              <strong class="alert__title">          자바스크립트에서 비교 연산        </strong>            <div class="alert__body">        <p>여기에서는 이해를 돕기 위해 생성자를 이용해 문자열이나 정수를 생성하고 있지만, 자바스크립트에서 생성자를 이용해 원시 타입 객체를 생성하면 비교 연산 시 참조를 이용해 비교합니다. 따라서 항상 리터럴 표기법으로 값을 다루기 바랍니다.</p><pre style='display:block'><code class='language-javascript'>    new String('Hello') === new String('Hello'); // false    new Number(5) === new Number(5); // false</code></pre>      </div>    </div>  <p>값 객체는 값을 이용해 새로운 값을 만들어 낼 수 있지만 값 자체를 변경할 수 없습니다. 즉, 불변입니다.</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>num <span class="token operator">=</span> num <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>num<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5</span></code></pre><p>위에서 숫자 <code>2</code>를 생성한 후 숫자 <code>3</code>을 더해 숫자 <code>5</code>를 얻고 있습니다. 숫자 <code>2</code>에 숫자 <code>3</code>을 더하는 것은 값 자체를 바꾸는 것이 아니라 새로운 값을 생성하는 것입니다. 이러한 특징은 상태를 변화시키지 않으며 새로운 값을 생성하는 함수형 스타일(functional style)과 닮았습니다.</p><h2 id="React-js와-불변객체"><a href="#React-js와-불변객체" class="headerlink" title="React.js와 불변객체"></a>React.js와 불변객체</h2><p>React 컴포넌트의 라이프 사이클 메서드 중에는 <code>shouldComponentUpdate</code> 메서드가 있습니다. 이 메서드는 컴포넌트가 다시 그려지기 전에 호출되며 만약 <code>false</code>를 반환하면 컴포넌트의 VirtualDOM을 비교하지 않습니다.</p><p>다량으로 엘리먼트를 출력하는 리스트나 피드와 같은 컴포넌트는 매번 VirtualDOM을 비교하게 되면 성능 문제가 발생할 수 있으므로 필수로 사용해야 하는 메서드입니다(대도록이면 모든 컴포넌트에 작성하는 습관을 들이는게 좋습니다).</p><h3 id="가변-객체일-때"><a href="#가변-객체일-때" class="headerlink" title="가변 객체일 때"></a>가변 객체일 때</h3><p>잘 알려진 TodoMVC를 예를 들어 설명하겠습니다.</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// todoItem.js</span><span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> nextState</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    nextProps<span class="token punctuation">.</span>todo <span class="token operator">!==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>todo <span class="token operator">||</span>    nextState<span class="token punctuation">.</span>label <span class="token operator">!==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>label  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>todoItem 컴포넌트의 <code>shouldComponentUpdate</code> 메서드는 prop 속성으로 전달된 todo 객체를 비교하여 VirtualDOM을 비교할지 말지 결정하고 있습니다.</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// todoHome.js</span><span class="token function">onUpdate</span><span class="token punctuation">(</span><span class="token parameter">todoId<span class="token punctuation">,</span> label</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>todos<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>todoId<span class="token punctuation">,</span> label<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// todos.js</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token parameter">todoId<span class="token punctuation">,</span> label</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> todo <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_todos<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">todo</span><span class="token punctuation">)</span> <span class="token operator">=></span> todo<span class="token punctuation">.</span>id <span class="token operator">===</span> todoId<span class="token punctuation">)</span><span class="token punctuation">;</span>    todo<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>label<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'update'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>특정 todo의 label 값을 변경하라고 todos 모델 객체에 요청하고 있습니다. todos 모델 객체는 자신이 관리하는 todo 객체들 중 하나를 찾아서 값을 변경하고 변경 사실을 통지합니다. 하지만 todoItem 컴포넌트의 단순한 비교문으로는 todo 객체의 값이 변경됐는지 알 수 없습니다.</p><p>todos 모델 객체에서 관리하는 todo 객체와 prop 속성으로 전달된 todo 객체의 참조가 동일하기 때문에 항상 참이되므로 의도한 결과를 얻을 수 없는 것입니다.</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// todoItem.js</span><span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> nextState</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    nextProps<span class="token punctuation">.</span>todo<span class="token punctuation">.</span><span class="token function">label</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>todo<span class="token punctuation">.</span><span class="token function">label</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span>    nextProps<span class="token punctuation">.</span>todo<span class="token punctuation">.</span><span class="token function">completed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>todo<span class="token punctuation">.</span><span class="token function">completed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span>    nextState<span class="token punctuation">.</span>label <span class="token operator">!==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>label  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><code>shouldComponentUpdate</code> 메서드의 비교문을 변경했습니다. 조금 복잡해졌습니다. 만약 하나의 객체에서 관리하고 있는 상태가 많을수록 이 비교문은 아주 복잡해질 것입니다.</p><p>하지만 여전히 이 코드는 동작하지 않습니다. todos 모델 객체에서 특정 todo 객체의 상태를 변경하면 같은 todo 객체를 참조하는 todoItem 컴포넌트에도 동일하게 반영돼 상태가 변경됐는지 알 수 없습니다. 이처럼 가변 객체의 참조를 가지고 있는 어떤 장소에서 객체를 변경하면 참조를 공유하는 모든 장소에서 그 영향을 받기 때문에 객체를 참조로 다루기란 쉽지 않습니다.</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// todoHome.js</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> todos <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>todos<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">todo</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">&amp;</span>lt<span class="token punctuation">;</span>TodoItem key<span class="token operator">=</span><span class="token punctuation">&#123;</span>todo<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> todo<span class="token operator">=</span><span class="token punctuation">&#123;</span>todo<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>        <span class="token operator">&amp;</span>lt<span class="token punctuation">;</span>ul<span class="token operator">></span><span class="token punctuation">&#123;</span>todos<span class="token punctuation">&#125;</span><span class="token operator">&amp;</span>lt<span class="token punctuation">;</span><span class="token operator">/</span>ul<span class="token operator">></span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>이번엔 <code>clone</code> 메서드를 이용해서 todo의 객체 상태를 전부 복사하여 새로운 todo 객체를 만들어 todoItem 컴포넌트에 전달하고 있습니다. 이러한 방법을 방어적 복사(defensive copy)라고 합니다.</p><p>드디어 코드는 의도한대로 동작하겠지만, 비교문은 여전히 복잡하며 매번 객체를 전체적으로 복사하는건 성능면에서 좋지 않습니다. 또, 객체의 전달 방식이나 사용 방식을 예의주시해야하는 번거로움도 수반됩니다.</p><h3 id="불변-객체일-때"><a href="#불변-객체일-때" class="headerlink" title="불변 객체일 때"></a>불변 객체일 때</h3><p>이제 todos 모델 객체의 update 메서드를 <a href="https://facebook.github.io/immutable-js/">Immutable.js</a>를 이용해 불변 객체로 관리하도록 변경해보겠습니다.</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// todos.js</span><span class="token keyword">class</span> <span class="token class-name">Todos</span> <span class="token keyword">extends</span> <span class="token class-name">events<span class="token punctuation">.</span>EventEmitter</span> <span class="token punctuation">&#123;</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>_todos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Immutable<span class="token punctuation">.</span>List</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// ... 생략 ...</span>    <span class="token function">update</span><span class="token punctuation">(</span><span class="token parameter">id<span class="token punctuation">,</span> label</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 새로운 List 객체를 생성한다.</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>_todos <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_todos<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>_todos<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span><span class="token parameter">t</span> <span class="token operator">=></span> t<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">)</span> <span class="token operator">===</span> id<span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token parameter">t</span> <span class="token operator">=></span> t<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'label'</span><span class="token punctuation">,</span> label<span class="token punctuation">)</span> <span class="token comment">// 새로운 todo 객체를 생성한다.</span>        <span class="token punctuation">)</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'update'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>todos 객체의 생성자 메서드를 통해 Immutable.js의 List 객체를 생성하고 있습니다. 특정 todo 객체의 값을 변경할 때는 List 객체의 update 메서드를 이용해 새로운 상태를 갖는 todo 객체와 List 객체를 다시 생성하여 설정합니다.</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// todoItem.js</span><span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> nextState</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>        nextProps<span class="token punctuation">.</span>todo <span class="token operator">!==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props <span class="token operator">||</span>        nextState<span class="token punctuation">.</span>label <span class="token operator">!==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>label    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>이제 비교문이 다시 단순해졌습니다. 객체의 상태가 변하지 않는 한 참조는 항상 같을 것이고, 객체의 상태가 변경될때만 새로운 객체가 생성되므로 참조가 달라집니다. 따라서 단순히 참조만 비교하는 것 만으로도 객체의 상태가 변경됐는지 판단할 수 있습니다.</p><p>매번 객체를 새로 생성하면 메모리 관리 시스템에 부담을 줄 수 있다고 생각할 수 있지만 이 점이 시스템 전체적인 병목을 일으키진 않습니다. 오히려 객체의 값을 전체적으로 복사하는 방어적 복사가 더 부담이 될 수 있습니다.</p><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><p>불변 객체는 값을 복사할 필요 없습니다. 객체를 복사할 때는 항상 같은 객체를 참조하는 주소만 반환하면 됩니다. 즉, 객체를 하나 생성하고 이를 지속적으로 재사용할 수 있습니다(Intern) 이처럼 불변 객체는 복사를 단순화할 수 있어 성능적으로 유리할 수 있습니다. 동일한 값을 여러번 복사해도 참조를 위한 포인터 크기 만큼만 메모리가 늘어날 뿐입니다.</p><p>또한 React.js의 <code>shouldComponentUpdate</code> 메서드를 통해 알 수 있듯이 비교문을 크게 단순화할 수 있습니다. 이 점이 React.js에서 불변 객체를 사용했을때 가장 피부로 체감할 수 있는 부분입니다. 단순한 비교문은 코드를 관리하기 쉽게 만들어줍니다. 반면, 가변 객체를 여러 뷰 컴포넌트에서 의존하면 이를 추적하고 관리하기 쉽지 않을 뿐더러 비교문도 작성하기 어렵습니다.</p><p><a href="https://facebook.github.io/flux">Flux 아키텍처</a>에서 말하는 단방향 데이터 흐름과 Immutable.js의 불변 객체, 그리고 수동적인 뷰 특징을 가진 리액트 컴포넌트가 한데 어울어지면 보다 단순하고 사고하기 쉬운 프로그램을 작성할 수 있습니다.</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://ko.wikipedia.org/wiki/%EB%B6%88%EB%B3%80%EA%B0%9D%EC%B2%B4">위키피디아:불변객체(한글)</a></li><li><a href="https://en.wikipedia.org/wiki/String_interning">위키피디아:인턴(영어)</a></li><li><a href="http://wit.nts-corp.com/2015/03/04/3118">7 Patterns to Refactor JavaScript Applications(한글)</a></li><li><a href="http://www.yes24.com/24/Goods/2824034?Acode=101">켄트 벡의 구현 패턴</a></li></ul>]]></content>
    
    
    <summary type="html">불변객체(Immutable Object)의 개념과 React에 그 개념을 적용했을 때 어떤 이점을 얻을 수 있는지 소개합니다.</summary>
    
    
    
    <category term="JavaScript" scheme="http://blog.coderifleman.com/categories/JavaScript/"/>
    
    <category term="React" scheme="http://blog.coderifleman.com/categories/JavaScript/React/"/>
    
    
    <category term="JavaScript" scheme="http://blog.coderifleman.com/tags/JavaScript/"/>
    
    <category term="React" scheme="http://blog.coderifleman.com/tags/React/"/>
    
    <category term="Immutable Object" scheme="http://blog.coderifleman.com/tags/Immutable-Object/"/>
    
  </entry>
  
</feed>
